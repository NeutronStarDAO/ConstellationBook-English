<!DOCTYPE HTML>
<html lang="zh-CN" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>ICCookbook</title>
        <meta name="robots" content="noindex" />


        <!-- Custom HTML head -->
        
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="The IC cookbook for you.">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="theme/style.css">


    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');
                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }
                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="index.html">ICCookbook</a></li><li class="chapter-item expanded affix "><a href="JourneytoWeb3/JourneyoftheDreamWeaver.html">Journey of the Dream Weaver</a></li><li class="chapter-item expanded affix "><li class="part-title">Overview of IC</li><li class="chapter-item expanded "><a href="OverviewofIC/OverviewofIC.html"><strong aria-hidden="true">1.</strong> Internet Computer</a></li><li class="chapter-item expanded "><a href="Glossary.html"><strong aria-hidden="true">2.</strong> Glossary</a></li><li class="spacer"></li><li class="chapter-item expanded affix "><li class="part-title">Core Protocol</li><li class="chapter-item expanded "><a href="2.CoreProtocol/Peer-to-peerLayer.html"><strong aria-hidden="true">3.</strong> Peer-to-peer layer</a></li><li class="chapter-item expanded "><a href="2.CoreProtocol/IntroductiontoConsensusLayer.html"><strong aria-hidden="true">4.</strong> Consensus Layer</a></li><li class="chapter-item expanded "><a href="2.CoreProtocol/Messageroutinglayer.html"><strong aria-hidden="true">5.</strong> Message routing layer</a></li><li class="chapter-item expanded "><a href="2.CoreProtocol/ExecutionLayer.html"><strong aria-hidden="true">6.</strong> Execution Layer</a></li><li class="spacer"></li><li class="chapter-item expanded affix "><li class="part-title">Chain key</li><li class="chapter-item expanded affix "><li class="part-title">NNS</li><li class="chapter-item expanded affix "><li class="part-title">Economic Model</li><li class="chapter-item expanded affix "><li class="part-title">canister</li><li class="chapter-item expanded affix "><li class="part-title">Internet Identity</li><li class="chapter-item expanded affix "><li class="part-title">Cryptography in IC</li><li class="chapter-item expanded affix "><li class="part-title">Dapp Development</li><li class="spacer"></li><li class="chapter-item expanded affix "><a href="Contributors.html">Contributors</a></li><li class="chapter-item expanded affix "><a href="References.html">References</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">ICCookbook</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/NeutronStarDAO/ICCookBook-English" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');

                    // Get viewed page store
                    var viewed_key = 'mdbook-viewed';
                    var viewed_map = {};
                    try {
                        var viewed_storage = localStorage.getItem(viewed_key);
                        if (viewed_storage) {
                            viewed_map = JSON.parse(viewed_storage)
                        }
                    } catch (e) { }

                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                        
                        // Apply viewed style
                        if (viewed_map[link.pathname]) {
                            link.classList.add('md-viewed')
                        }
                    }); 

                    // Mark viewed after 30s
                    setTimeout(function() {
                        viewed_map[location.pathname] = 1;
                        localStorage.setItem(viewed_key, JSON.stringify(viewed_map));
                    }, 30000)
                </script>

                <div id="content" class="content">
                    <!-- Page table of contents -->
                    <div class="sidetoc"><nav class="pagetoc"></nav></div>
                    <main>
                        <h1 id="iccookbook"><a class="header" href="#iccookbook">ICCookbook</a></h1>
<img src="assets/README/iclogo.png" align="right" alt="DFINITY logo" width="270" />
<p>If you have only heard of IC but have been busy with Ethereum and Polkadot projects without delving into IC, then you've come to the right place to learn more about it <a href="./OverviewofIC/OverviewofIC.html">here</a>!</p>
<p>If you are still unfamiliar with Web3, blockchain, Bitcoin, and IC, don't worry, start <a href="./JourneytoWeb3/JourneyoftheDreamWeaver.html">here</a>. Let me guide you through the history of encryption and quickly get you started in Web3 development!</p>
<p><strong>This project is currently under rapid development...</strong> </p>
<h2 id="coming-soon-"><a class="header" href="#coming-soon-">Coming Soon ...</a></h2>
<br>
<h3 id="why-write-this-book"><a class="header" href="#why-write-this-book">Why write this book?</a></h3>
<p>Initially, after learning about IC, I collected and organized information from the IC whitepaper, Medium, ICPL Forum, and IC Developer Forum. After explaining the IC architecture to a friend, I told her that I was compiling notes on IC information to share once I finished organizing them. Unexpectedly, it took a year to organize them after a long period of procrastination. Later, after learning more, I finally compiled the first version of my notes. After further study, I thought it would be best to share these notes as an open-source book to help everyone learn about IC and contribute to the IC developer community.</p>
<br>
<h3 id="why-make-it-open-source"><a class="header" href="#why-make-it-open-source">Why make it open source?</a></h3>
<p>I love the Rust open-source community, which has many open-source books and projects that have been very helpful to me. I have learned a lot from the Rust open-source community. Projects like Bitcoin, Ethereum, and related ones also have a strong open-source atmosphere, and I hope that the IC community will also have more and more open-source projects for everyone to learn from.</p>
<p>Additionally, IC's content updates quickly, and open-source contributions help keep the content fresh and up-to-date.</p>
<br>
<h3 id="why-call-it-the-ic-cooking-guide"><a class="header" href="#why-call-it-the-ic-cooking-guide">Why call it &quot;The IC Cooking Guide&quot;?</a></h3>
<p>I hope to be a chef of knowledge, carefully preparing, marinating, and stewing knowledge into a work of art. I want to make knowledge extremely user-friendly, accessible, easy to understand, and engaging for beginners. I will explain complex and large concepts using simple language, including the underlying logic behind them.</p>
<br>
<p>Join the developer discussion group for this book, make corrections, suggest changes, and contribute to this open-source book together!</p>
<p>Discord: https://discord.gg/5Y8QPHvR</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="journey-of-the-dream-weaver"><a class="header" href="#journey-of-the-dream-weaver">Journey of the Dream Weaver</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="overview-of-ic"><a class="header" href="#overview-of-ic">Overview of IC</a></h1>
<div style="break-before: page; page-break-before: always;"></div><div style="break-before: page; page-break-before: always;"></div><h1 id="peer-to-peer-layer"><a class="header" href="#peer-to-peer-layer">Peer-to-peer layer</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="introduction-to-consensus-layer"><a class="header" href="#introduction-to-consensus-layer">Introduction to Consensus Layer</a></h1>
<h2 id="what-pouw-isnt-it-pow"><a class="header" href="#what-pouw-isnt-it-pow">What? PoUW? Isn't it Pow?</a></h2>
<p>Consensus on IC ? Take a look at this term: PoUW, Proof of Useful Work.</p>
<p>Does it looks familiar to you?</p>
<img src="2.CoreProtocol/assets/Introduction to Consensus Layer/image-20230131200036914.png" alt="image-20230131200036914" style="zoom:20%;" />
<p>Proof of Work (PoW) is the consensus algorithm of Bitcoin, which is very inefficient from today's perspective, but still it is relatively secure. </p>
<p>What is Proof of Work ? </p>
<p>Imagine a school organizing an competitive exam, only students who get full marks are eligible to put their names on the &quot;Honor Wall&quot; of the Education Bureau, they will be also rewarded with one full bitcoin! The school is open 24 hours a day, anyone can come and take the exam at any time, and the results will be released automatically after finishing all the questions. After one student gets full marks, the answer sheets of students who are still taking the exam will be immediately invalidated. That is because the answer (full mark paper) has already been born. In addition,other students must copy the full mark paper and then start the next exam.</p>
<p>In the school of PoUW, the candidates are randomly divided into several classes, and the exams are conducted in these classes. This time,not everyone can enter the school but only teachers can join. Each class completes a set of questions together. Since everyone is supposed to be an experienced teacher, they will roll the dice to decide who gets to do the first question, and who gets to do the second ... After finishing the questions, everyone has to discuss and reach a consensus on various opinions, and then hand in the papers eventually. Each person in the class shares the reward equally.</p>
<br>
<p>How efficient it is!😉😎</p>
<p>PoUW adds a 'U' to PoW, it significantly improves performance and reduces useless work for node machines. PoUW does not artificially create difficult hash calculations. It tries to put as much computing power as possible into serving users of the network. Most resources (CPU, memory) are used to execute codes in Canisters.</p>
<h2 id="how-is-consensus-reached"><a class="header" href="#how-is-consensus-reached">How is consensus reached?</a></h2>
<p>No matter what, Bitcoin is one of ancestors of the blockchain. Even though the consensus is inefficient, it is a solution to distributed system issues.</p>
<p>Satoshi Nakamoto's Bitcoin is a feasible solution to the &quot;Byzantine generals problem&quot;.</p>
<p>Simply put, this problem involves attempts to reach consensus on a course of action through information exchange in an unreliable network with potential threats. Satoshi Nakamoto's solution used the concept of Proof of Work to reach consensus without a centralized authority that needs to be trusted, representing a scientific breakthrough in distributed computing and transcending the widespread applicability of currency.</p>
<br>
<p>However, can consensus only be reached in this way? Is there a more efficient way with high security?</p>
<p>Let's talk about the essence of consensus.</p>
<br>
<p>The essence of consensus is to maintain data consistency in a globally distributed network.</p>
<p>Bitcoin's approach is that everyone competes for computing power to determine who gets to pack valid blocks, then everyone has to copy the winner's blocks. In this way, Bitcoin transaction ledgers will have multiple copies, and the goal of keeping data consistent across all nodes is achieved. However, the efficiency is very low.</p>
<br>
<p>Let's take a look at the logic of consistency here:</p>
<p>The goal: Maintain data consistency across all nodes.</p>
<p>The method: Rely on some means to select a node to pack the block, and others copy the block packed by that node. The same node cannot be selected repeatedly in a continuous way, and the process of getting selected to pack the blocks is random.</p>
<p>Let us analyse the purpose only. Since the purpose is to maintain data consistency between nodes, as long as the nodes receive messages at the same time, the problem will be solved.</p>
<img src="2.CoreProtocol/assets/IntroductiontoConsensusLayer/image-20230531145221186.png" alt="image-20230531145221186" style="zoom:25%;" />
<p>In the actual network environment ,it could not be achieved. Information transmission always has varying delays, not to mention that nodes are not located in a same place. The locations of clients are also far and near,the transmission distances are different. It is chaotic and sounds impossible to guarantee that all nodes receive messages at the same time. What should we do?</p>
<p><img src="https://github.com/NeutronStarDAO/ICCookBook-English/assets/89145158/f162c208-3fbe-41c0-85fc-fd8381775760" alt="image" /></p>
<p>The answer is simple. Building a &quot;relay station&quot; can solve this problem. No matter where the messages come from, they are first queued in the relay station, then the relay station sends the messages and execution order to the nodes. As long as the nodes execute the operations in the order received from the relay station, data consistency can be guaranteed!</p>
<p>It is not over yet! Since there is another big issue: Centralization. All nodes have to obey the commands of the relay station. If the relay station says to execute messages in the order of ABDC, the nodes have to follow ABDC. Going round and round a big circle, the result returns to its starting point. So how can we sort messages in a decentralized way?</p>
<br>
<p>Decentralizing is actually simple, that is, doing something completely independent of any other one. There is no &quot;boss&quot; or &quot;manager&quot;.It is very democratic,  everyone works together to reach a consensus. Anyone who comes is allowed to pick up the jobs, and anyone who leaves will not affect the continuous operation of the system. (Unless everyone leaves, but with economic incentives, someone will always come!)</p>
<p>So how can we design it? The nodes need to reach consensus on the order of executing messages and we need to decentralize the working process of the relay station.</p>
<br>
<p>IC is designed like this: (IC abstracts nodes into replicas in subnets)</p>
<p>We could not rely on a relay station. Although the time for messages to arrive at each replica may be different (that is, the time of executing messages is different), all replicas must execute messages in the same order.</p>
<img src="2.CoreProtocol/assets/IntroductiontoConsensusLayer/6748452b-c774-40f5-bd91-d28a6ed85520.png" alt="image" style="zoom:25%;" />
<p>Then if everyone's order is different, which order should be executed? It will use random number to decide! (IC's Random Beacon)</p>
<p>IC uses a verifiable random function (VRF) at the base layer. It can generate unpredictable random numbers, and everyone can verify that the random numbers are not made by human.</p>
<p>VRF uses threshold BLS signature scheme. The threshold BLS signature algorithm uses DKG to distribute private key shares to replicas. This is a non-interactive distributed key generation protocol. DKG can distribute private key shares between members. There is no need for a trusted third-party, it does not depend on any member to distribute private key shares, avoiding single points of failure. Everyone uses the private key shares to sign information. Once the signature reaches the threshold, it can be aggregated into a complete signature. The signature process is non-interactive. Any third party can aggregate after receiving enough shares. Anyone can verify the signature with the unique public key. The public key is also recorded in the NNS registry.</p>
<br>
<p>If a message is confirmed, no matter which private key shares participate in the signature, as long as the threshold quantity is reached (the threshold for generating the Random Beacon is one-third), the final unique signature information can be aggregated. For example, the threshold in the following figure is 6. In order for the 16 replicas to generate the random beacon signature for this round, as long as the signature is greater than 6, it can be aggregated.</p>
<img src="2.CoreProtocol/./assets/IMG4.png" alt="image" style="zoom:25%;" />
<p>As long as the bad guys get less than one-third of the private key shares, they cannot interfere with the threshold BLS signature. It is also impossible to predict the signature result because the private key shares are not enough. That is to say, no one knows the signature result.</p>
<blockquote>
<p>The consensus of the subnet can resist up to less than one-third malicious replicas. If the malicious replicas are less than one-third, all they can do is sign or not sign, they are unable to interfere with the final result of the threshold signature, nor prevent the signature from being generated. If malicious replicas are greater than or equal to one-third, the subnet has been destroyed, so the random number does not matter. Therefore, the threshold for the random beacon is low, at one-third. The speed of generating random numbers can be faster.</p>
</blockquote>
<ul>
<li>In the traditional RSA algorithm, you control the private key and the message is public, which is equivalent to knowing the signature result yourself. After the private key is leaked, others can also know the signature result in advance.</li>
<li>However, in the threshold BLS  signature algorithm, a group of people control the private key shares. The signer himself does not have the complete private key, so he does not know the signature result. Only after everyone has signed and aggregated ,then they know the signature. Throughout the process, no one knows the global private key, but the signature result is the result recognized by most people. A group of people generate signatures, and no individual can predict the signature result. A single person cannot prevent the signature from being released.</li>
</ul>
<br>
<p>This can serve as Random Beacon to provide a reference for which replica to produce a block. This random number is also a consensus result and cannot be tampered with by a single person. Moreover, this can continuously safely generate random numbers, as long as different information is used for each round of signatures. This different information is naturally the random beacon and some block dkg_ids of the previous round, so that the information signed in each round is different.</p>
<p>IC's random beacon, notarization, finality, random tape, and certified copy status all use threshold BLS signatures. (The random tape and certified copy status are content at the execution layer)</p>
<br>
<h2 id="solution"><a class="header" href="#solution">Solution</a></h2>
<p>Let us take a closer look on how IC's consensus protocol produces a block</p>
<h3 id="preparation-before-block"><a class="header" href="#preparation-before-block">Preparation before block</a></h3>
<p>The consensus protocol produce block by rounds. For example, consensus is reached on the genesis block in round 1, and round 6 for block 6.</p>
<img src="2.CoreProtocol/assets/IntroductiontoConsensusLayer/f31ef6bf-b877-4548-9fdc-143f2f8e4685.png" alt="image" style="zoom:70%;" />
<p>Before start, the subnet first randomly selects some replicas to form a &quot;consensus committee&quot; according to the number of replicas. If the number of replicas is too low, all replicas will join the committee. The members in the committee are responsible for producing the blocks, so even if there are a large number of replicas in the subnet, it will not affect performance.</p>
<img src="2.CoreProtocol/assets/IntroductiontoConsensusLayer/6af04a3f-b9b1-44b5-b0ff-87fcfddbe9ee.png" alt="image" style="zoom:67%;" />
<p>There is also the concept of &quot;epoch&quot; in the subnet. An epoch is approximately a few hundred rounds. The NNS can adjust the epochs for each subnet.</p>
<p>Each subnet operates within epochs that contain multiple rounds (typically around a few hundred rounds). Different replicas make up the committees in each epoch.</p>
<p><img src="2.CoreProtocol/assets/IntroductiontoConsensusLayer/47e1f2e9-5717-4b5d-b1a2-1b788b10803b.png" alt="image" /></p>
<p>At the end of each epoch, the consensus committee members for the next epoch are selected through the random beacon, and the current consensus committee members will all become random beacon committee members in the next epoch.</p>
<br>
<p>The first block of the new epoch contains the list of consensus committee members and random beacon committee members for this epoch.</p>
<p>And at the beginning of the new epoch, the private key shares will be redistributed to the members. This process is called Pro-active resharing of secrets. There are two reasons for doing this:</p>
<ul>
<li>When the members of the subnet change, resharing can ensure that any new member will have new private key shares, and any member exiting the subnet will not have a new private key share.</li>
<li>Even if a small amount of private key shares are leaked to attackers in each epoch, it will not threaten the consensus.</li>
</ul>
<br>
<p>The number of consensus committees is related to the total number of replica members in the subnet. To improve scalability, in small-scale networks, committee members can be all replicas. In large-scale networks, committee members are part of all replicas and constantly changing in each epoch.</p>
<br>
<p>The number of consensus committee members cannot be too large or too small. Too few are insecure, too many affect the consensus speed.</p>
<p>So the relationship between the number of committees and the total number of members has a mathematical model to describe: When the total number of members in the subnet tends to infinity, the hypergeometric distribution tends to the binomial distribution, that is, non-replacement random sampling tends to replacement random sampling. Because the total number of replica members is infinite, there is no difference between replacement and non-replacement. If you are interested, you can read the introduction <strong>here</strong>.</p>
<br>
<p>Once the preparation is complete, blocks can be produced.</p>
<br>
<h3 id="block-maker"><a class="header" href="#block-maker">Block Maker</a></h3>
<p>At the start of each round, the random beacon generated from the previous round produces a ranking to determine the weight of members to produce blocks. The leader with the highest weight is given priority to produce blocks. (As shown in the figure below, the ranking assigns a number from 0 to 4 to the 5 consensus committee members, with 0 having the highest weight)</p>
<p>Under normal circumstances, the leader is honest and the network connection is normal. The leader is responsible for producing blocks. Others are waiting to notarize the leader's block. Even if block from the 2nd maker is received, it will not be notarized until the leader's block is received.</p>
<p>At the same time, the random beacon committee will also package, sign and broadcast the hash of the previous round's beacon and the NiDKG record of this round. When the signature reaches the threshold, this round's random beacon is generated, which also determines the block production weight for the next round.</p>
<img src="2.CoreProtocol/assets/IntroductiontoConsensusLayer/6686cda7-0c23-4ae3-aa95-f2f7dffd836b.png" alt="image" style="zoom:70%;" />
<p>A non-genesis block generally contains:</p>
<ul>
<li>The messages received from the time the previous block was notarized to the time this block was packaged, called the &quot;payload&quot;.</li>
<li>The hash of the previous block.</li>
<li>The ranking of the block-producing replica.</li>
<li>The height of the block.</li>
</ul>
<br>
<p>After the block is assembled, the replica responsible for producing the block will generate a <strong>block proposal</strong>, including:</p>
<ul>
<li>The block itself.</li>
<li>Its own identity.</li>
<li>Its own signature on this block.</li>
</ul>
<img src="2.CoreProtocol/assets/IntroductiontoConsensusLayer/e8ad34e1-b042-46b8-af32-4da9f28d88ac.png" alt="image" style="zoom:67%;" />
<p>Then broadcast the block proposal to other members.</p>
<p>The leader produces a block and broadcasts it to everyone. After notarization is completed, since only the leader's block is notarized, there is no need for finalization, and it enters the next round. This is the fastest and most common situation. About 1 second to finalize a block. (Optimistic responsiveness: The protocol will continue to execute based on actual network latency rather than the upper limit of network latency)</p>
<br>
<p>If after waiting for a period of time, the leader's block has not been received, it may be that the leader has a poor network or the machine has malfunctioned. Only then will members accept block from 2nd member or 3rd member and notarize their blocks.</p>
<p><img src="2.CoreProtocol/assets/IntroductiontoConsensusLayer/bb3cce3c-7016-4f4e-94b2-1b41c2c0ea21.png" alt="image" /></p>
<p>The system has an agreed upon waiting time. If the leader's block is not received within a period of time, it will expect block 2 in the second time period. Then in the third time period, block 3 is expected. If block 3 is its own, then produce the block itself ...</p>
<br>
<h3 id="notarization"><a class="header" href="#notarization">Notarization</a></h3>
<p><strong>Notarization only verifies the reasonableness of the block</strong>, and the notarized block does not represent consensus. This ensures that at least one block in the current round can be notarized.</p>
<p>Therefore, notarization does not mean consensus, nor does it require consensus. If multiple blocks have the same weight, these blocks will be signed.</p>
<br>
<p>During notarization, the members of the consensus committee verify the following three aspects:</p>
<ol>
<li>The block should contain the hash of the block already notarized in the previous round.</li>
<li>The payload of the block must meet certain conditions (specific regulations on the payload content, these conditions are independent of the consensus protocol).</li>
<li>The ranking of the replica responsible for producing this block must correspond to the ranking in the random beacon (for example, if the replica ranked second claims to be ranked first, then this block will not be notarized).</li>
</ol>
<br>
<p>If the block information is correct, the replica responsible for verification first signs the block height and block hash, and then forms a &quot;<strong>notarization share</strong>&quot; with the just signed signature, hash, height, and its own identity. Broadcast the notarized shares.</p>
<img src="2.CoreProtocol/./assets/IMG11.png" alt="image" style="zoom:20%;" />
<p>Notarization also uses BLS threshold signatures. When a replica receives enough (the threshold is two-thirds) notarization share, it aggregates the signature share to form a notarization for this block.</p>
<img src="2.CoreProtocol/./assets/IMG12.png" alt="image" style="zoom:17%;" />
<p>The aggregated notarization information includes the block hash, block height, aggregated signature, and more than two-thirds of the identity identifiers. Replicas either find that they have collected enough notarization shares and aggregate them into notarizations themselves; or they receive aggregated notarizations from others.</p>
<img src="2.CoreProtocol/assets/IntroductiontoConsensusLayer/ebb8aa45-a9a7-412f-8c18-68b0c80f5ccf.png" alt="image" style="zoom:75%;" />
<p>After notarization, the block is still broadcast. When other members receive the already notarized block, they re-broadcast the notarized block and do not generate notarization shares for other blocks.</p>
<br>
<p>For example, in the figure below, the girl holding the cell phone and the blue hat enter the next round of consensus. When the girl sends messages to the other three people, the network is interrupted for 700 milliseconds. The message forwarded by the little blue hat plays a key role. Otherwise, five missing three would not be able to work.</p>
<img src="2.CoreProtocol/assets/IntroductiontoConsensusLayer/0a476c14-a9ca-4a25-83e8-bea3d7eff1c8.png" alt="image" style="zoom:25%;" />
<p>If the leader's block has a problem and the notarization fails, the weighting of the second block will now be the largest. If the blocks of the second and the third have both passed notarization, the leader of the next round will choose to block after the block with the greatest weight. As in rounds 5 and 6 below, the weight of the second block is greater than the weight of the third block. Adding up the weights of all blocks, the chain composed of yellow and purple blocks is the chain with the greatest weight.</p>
<img src="2.CoreProtocol/assets/IntroductiontoConsensusLayer/6a44e5fe-493d-4cb2-85c7-afd1a0c472f0.png" alt="image" style="zoom:70%;" />
<br>
<h3 id="finalization"><a class="header" href="#finalization">Finalization</a></h3>
<p>Because sometimes more than one block may be generated (when the leader does not respond, the second and the third may produce block to save time). This requires a finalization. The finalization stage will determine the only block that everyone has notarized. Then the blocks before the block that everyone agrees with will also be implicitly finalized, and other branches will become invalid.</p>
<img src="2.CoreProtocol/assets/IntroductiontoConsensusLayer/a47ea62b-5d12-4b59-afd1-df442fab6669.png" alt="image" style="zoom:23%;" />
<p>The finalization process is specifically:</p>
<p>After a replica finds a notarized block, it will start checking whether it has notarized any other blocks in this round. If it has not notarized any other blocks, it will broadcast a &quot;finalization share&quot; for the block. To prove that it has only issued a notarization share for this block.</p>
<p>To achieve the finalization of a block, two-thirds of different replicas need to issue finalization share, and then aggregate for the finalization of a block. The format of the finalization share is exactly the same as the notarization share (but marked in a specific way to prevent confusion). After receiving the finalized block, like the notarization process, it will broadcast to other members again.</p>
<p>Note: The replica does not deliberately wait for the aggregation of the finalization share into the finalized before entering the next round. After receiving a finalization share of a certain height, the replica only checks whether it has notarized blocks other than that block, and then broadcasts its own signed finalization share; or forwards the finalization share intact.</p>
<br>
<p>For example, after a replica receives the finalization share of round 10 in round 11, it will check its behaviour at that time and then broadcast a reply.</p>
<p>If after a while, if you receive the finalization of the block in round 10, you can implicitly consider all previous blocks as finalized.</p>
<img src="2.CoreProtocol/assets/IntroductiontoConsensusLayer/3142ef13-478b-4683-bbf4-10cea35414fa.png" alt="image" style="zoom:73%;" />
<p>These finalized blocks can be considered as safe confirmed by everyone, meaning that all replicas agree with the branch where the finalized block is located. At the height of block 10, only this block has passed notarization. Then the replica reaches consensus at this height.</p>
<br>
<p>For example:</p>
<p>If a replica only generates a notarization share for one block in Round 5, the replica will also issue a finalization share and then enter Round 6 consensus. If the finalization is received later, the branch containing the finalization is considered valid. If the finalization does not fork afterwards, there will be no problem without finalization.</p>
<p>It is possible that in Round 4, half of the replicas generated notarization shares for the leader and the second blocks, and the other half of the replicas only generated notarization shares for the leader's block. Then the finalization share proposed by the replicas that only notarized the leader's block cannot reach the threshold and cannot obtain finalization. Only half of the replicas generate notarization shares for the second member's block, so the second member's block does not obtain notarization.</p>
<img src="2.CoreProtocol/assets/IntroductiontoConsensusLayer/3925837b-88e0-4d66-b75f-51ebe3794b74.png" alt="image" style="zoom:67%;" />
<p>Compared with many other blockchains, the advantage of the IC consensus protocol is that it adopts asynchronous finalization. In other blockchains, nodes usually need to find the longest chain. If the chain forks, the nodes need to wait for a while to find the longest chain. If some blocks are missed due to network failures, the longest chain cannot be found, and data from other nodes needs to be synchronized.</p>
<p>The IC protocol does not rely on finding the &quot;longest chain&quot; to eventually confirm the block. IC's finality method only relies on cryptographic signatures, not on the confirmation of the entire chain. A small number of signatures can observe a block consensus formed without waiting for the confirmation of the entire chain. Forks can be eliminated in a short time, and finalization speeds can be achieved in less than one second.</p>
<br>
<p><strong>The consensus process is over here!</strong></p>
<br>
<p>To summarize, the members of the Consensus Committee need to do 3 things when entering a new round:</p>
<p>(1) See how they rank and then decide whether to produce block yourself</p>
<p>(2) Notarize the block</p>
<p>(3) Observe the blocks, find the main chain, and ignore invalid branches</p>
<p>The Consensus Committee will become a random beacon committee in the next period and be responsible for generating random beacons for each round.</p>
<br>
<p>The consensus process is for the leader to block, everyone verifies and then issues a notarization share, the notarization share reaches the threshold and aggregates into notarization, and enters the next round. Finalization does not have to be completed every round.</p>
<p>The IC consensus protocol ensures that when there are individual malicious attacks, IC's performance will flexibly decrease instead of directly freezing. The consensus protocol currently tends to maximize performance as much as possible in the &quot;optimistic case&quot; without failures.</p>
<p>As the protocol progresses round by round, the blocks connected from the genesis block form a chain that extends continuously. Each block contains a payload, consisting of a series of inputs and the hash of the parent block.</p>
<p>Honest replicas have a consistent view of the path of the blockchain. The blocks record the messages that have been sorted, which are sent by the message routing layer to the execution layer for processing.</p>
<br>
<br>
<h2 id="source-code"><a class="header" href="#source-code">Source Code</a></h2>
<p>https://github.com/dfinity/ic/tree/master/rs/consensus/src/consensus</p>
<h3 id="random_beacon_maker"><a class="header" href="#random_beacon_maker">random_beacon_maker</a></h3>
<p>Threshold BLS signature</p>
<h3 id="on_state_change"><a class="header" href="#on_state_change">on_state_change</a></h3>
<p>If it meets the requirements for proposing random beacon sharing, propose it.</p>
<p>It contains a function called <code>on_state_change</code>. This function accepts a parameter pool of type <code>PoolReader</code> and returns a value of type <code>Option&lt;RandomBeaconShare&gt;</code>. The function of this function is to obtain the current node information and the information in the pool, and determine whether the current node needs to generate a random beacon based on this information. If a random beacon needs to be generated, generate the beacon and return it encapsulated in the <code>RandomBeaconShare</code> structure.</p>
<p>The function first obtains the ID and current height of the current node, and then obtains the random beacon corresponding to the height from the pool. Next, it gets the next height and tries to get the random beacon corresponding to that height from the pool. If the pool does not have this random beacon and the current node belongs to the random beacon committee of that height, generate the random beacon and return it.</p>
<p>The process of generating a random beacon involves creating a <code>RandomBeaconContent</code> structure, which contains the height and hash value. Then, the function will call a function named <code>active_low_threshold_transcript</code> to get the transcript of the current height. If the transcript can be successfully obtained, the <code>crypto.sign</code> method is called to sign the <code>RandomBeaconContent</code> structure. After the signature is successful, the function will return the signature information encapsulated in the <code>RandomBeaconShare</code> structure. If any step has a problem, the function will return <code>None</code>.</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn on_state_change(&amp;self, pool: &amp;PoolReader&lt;'_&gt;) -&gt; Option&lt;RandomBeaconShare&gt; {
    trace!(self.log, &quot;on_state_change&quot;);
    let my_node_id = self.replica_config.node_id;
    let height = pool.get_notarized_height(); // get notarized height of blocks 
    let beacon = pool.get_random_beacon(height)?; // get a random beacon(From pervious round)
    let next_height = height.increment(); // That is the height of the current round (everyone is signing blocks, no decisive blocks have been made, so it's called &quot;next block&quot;).
    let next_beacon = pool.get_random_beacon(next_height); // Get the random beacon for the next block height.
    match self.membership.node_belongs_to_threshold_committee(
        my_node_id,
        next_height,
        RandomBeacon::committee(),
    ) {
        Err(MembershipError::RegistryClientError(_)) =&gt; None,
        Err(MembershipError::NodeNotFound(_)) =&gt; {
            panic!(&quot;This node does not belong to this subnet&quot;)
        }
        Err(MembershipError::UnableToRetrieveDkgSummary(h)) =&gt; {
            error!(
                self.log,
                &quot;Couldn't find transcript at height {} with finalized height {} and CUP height {}&quot;,
                h,
                pool.get_finalized_height(),
                pool.get_catch_up_height()
            );
            None
        }
        Ok(is_beacon_maker)
       // This code uses a match expression that matches a tuple containing two elements.
// The first element is a boolean indicating whether a new random beacon needs to be created for the next height;
// The second element is the next height.
//
// If the first element is true, the first arm is executed, otherwise the second arm is executed.
//
// In the first arm, if the current node is a beacon maker and no random beacon has been generated for the next height
// and the current node has not obtained a share of the random beacon for the next height, then create a random beacon.
// In the second arm, return None.
            if is_beacon_maker
                &amp;&amp; next_beacon.is_none()
                &amp;&amp; !pool
                    .get_random_beacon_shares(next_height)
                    .any(|s| s.signature.signer == my_node_id) =&gt;
        {
            let content =
            // Hash the previous random beacon
            RandomBeaconContent::new(next_height, ic_types::crypto::crypto_hash(&amp;beacon));
// There is an issue of whether it is appropriate to use the dkg_id of the genesis block h
// to generate a random beacon for height h. The reason this is possible is that we actually only generate
// a random beacon for height h after a block at height h exists, and we only use the random
// beacon for height h-1 when verifying the block at height h. Therefore, using the dkg_id
// of the genesis block to generate the random beacon will not affect the validity and correctness of the blocks,
// because in fact the random beacon is only used after the blocks are generated to determine the ranking
// of replica block generation in the next round.
            if let Some(transcript) =
                active_low_threshold_transcript(pool.as_cache(), next_height)
            {
                match self.crypto.sign(&amp;content, my_node_id, transcript.dkg_id) {
                    Ok(signature) =&gt; Some(RandomBeaconShare { content, signature }),
                    Err(err) =&gt; {
                        error!(self.log, &quot;Couldn't create a signature: {:?}&quot;, err);
                        None
                    }
                }
            } else {
                error!(
                    self.log,
                    &quot;Couldn't find the transcript at height {}&quot;, height
                );
                None
            }
        }
        _ =&gt; None,
    }
}
<span class="boring">}</span></code></pre></pre>
<h3 id="get_notarized_height"><a class="header" href="#get_notarized_height">get_notarized_height</a></h3>
<p>It has no parameters. The function returns a <code>Height</code> value.</p>
<p>The purpose of this function is to get the maximum height of the notarized blocks. The following is the implementation of this function:</p>
<p>First, use the <code>get_catch_up_height</code> method to get the highest catch-up package height that has not been processed, and store it in the <code>catch_up_height</code> variable.</p>
<p>Then, extract all verified notarizations from the pool and use the <code>max_height</code> method to get the maximum height of the notarized blocks. If no notarized blocks are found, return <code>catch_up_height</code>.</p>
<p>Finally, select the larger value from <code>catch_up_height</code> and the maximum height of the notarized blocks, and return it as the result.</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn get_notarized_height(&amp;self) -&gt; Height {
    let catch_up_height = self.get_catch_up_height();
    self.pool
        .validated()
        .notarization()
        .max_height()
        .unwrap_or(catch_up_height)
        .max(catch_up_height)
}
<span class="boring">}</span></code></pre></pre>
<h3 id="get_random_beacon"><a class="header" href="#get_random_beacon">get_random_beacon</a></h3>
<p>It has two parameters: <code>self</code>, which is a reference to an object instance, and <code>height</code>, which is a <code>Height</code> value. The function returns an <code>Option&lt;RandomBeacon&gt;</code>.</p>
<p>The purpose of this function is to get a valid random beacon at a given height. The following is the implementation of this function:</p>
<p>First, use the <code>cmp</code> method to compare the given height with the height returned by the <code>get_catch_up_height</code> method. <code>get_catch_up_height</code> returns the highest catch-up package height that has not been processed.</p>
<p>If the given height is less than the height returned by <code>get_catch_up_height</code>, it means that the random beacon at that height has not been generated yet, returning <code>None</code>.</p>
<p>If the given height is equal to the height returned by <code>get_catch_up_height</code>, it means that the random beacon at that height has been included in the highest catch-up package, so extract the random beacon from the catch-up package and return it wrapped in <code>Some</code>.</p>
<p>If the given height is greater than the height returned by <code>get_catch_up_height</code>, it means that the random beacon at that height has been verified in the pool. Therefore, extract the verified random beacon from the pool, and then use the <code>get_only_by_height</code> method to obtain the random beacon by the given height. If it can be obtained, return it, otherwise return <code>None</code>.</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn get_random_beacon(&amp;self, height: Height) -&gt; Option&lt;RandomBeacon&gt; {
    match height.cmp(&amp;self.get_catch_up_height()) {
        Ordering::Less =&gt; None,
        Ordering::Equal =&gt; Some(
            self.get_highest_catch_up_package()
                .content
                .random_beacon
                .as_ref()
                .clone(),
        ),
        Ordering::Greater =&gt; self
            .pool
            .validated()
            .random_beacon()
            .get_only_by_height(height)
            .ok(),
    }
}
<span class="boring">}</span></code></pre></pre>
<h3 id="active_low_threshold_transcript"><a class="header" href="#active_low_threshold_transcript">active_low_threshold_transcript</a></h3>
<p>It has two parameters: <code>reader</code>, which is a reference to an object implementing the <code>ConsensusPoolCache</code> trait, and <code>height</code>, which is a <code>Height</code> value. The function returns an <code>Option&lt;NiDkgTranscript&gt;</code>.</p>
<p>The purpose of this function is to get the active low threshold NiDkg transcript for a given height. The <code>get_active_data_at</code> function is called and passed <code>reader</code> and <code>height</code> as parameters. The return value is mapped to extract the <code>low_threshold_transcript</code> field of the returned data object.</p>
<p>If the <code>get_active_data_at</code> function returns None, the value of the entire expression is None. Otherwise, the <code>low_threshold_transcript</code> field will be extracted and returned wrapped in Option.</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// If found, return the current low transcript for the given height.
pub fn active_low_threshold_transcript(
    reader: &amp;dyn ConsensusPoolCache,
    height: Height,
) -&gt; Option&lt;NiDkgTranscript&gt; {
    get_active_data_at(reader, height).map(|data| data.low_threshold_transcript)
}
<span class="boring">}</span></code></pre></pre>
<h3 id="get_active_data_at"><a class="header" href="#get_active_data_at">get_active_data_at</a></h3>
<p>If active DKGData is found at the given height, return that DKGData.</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn get_active_data_at(reader: &amp;dyn ConsensusPoolCache, height: Height) -&gt; Option&lt;DkgData&gt; {
// There is an issue to note when determining the active DKG data. When using the latest finalized DKG summary,
// there is a problem that the next block or CUP cannot be calculated when the batch lags consensus. This is because only when
// the final block reaches a certain height and points to at least the notarization state of that height can we create the CUP. To solve this problem, the comment
// proposes a solution: first try to use the CUP summary block to determine the active DKG data, and if it fails, try to use the
// newest finalized DKG summary block. This avoids the situation where the next block or CUP cannot be calculated.
    get_active_data_at_given_summary(reader.catch_up_package().content.block.get_value(), height)
        .or_else(|| get_active_data_at_given_summary(&amp;reader.summary_block(), height))
}
<span class="boring">}</span></code></pre></pre>
<h3 id="get_active_data_at_given_summary"><a class="header" href="#get_active_data_at_given_summary">get_active_data_at_given_summary</a></h3>
<p>Returns the active DKGData (DKG data) at the given height according to the given summary block. A summary block is a block at a fixed height that contains some metadata, e.g. public keys for verifying the next consensus proof, digests of DKG data, etc. The height of a summary block is typically a multiple of some regular interval, e.g. one summary block every 100 blocks.</p>
<p>The summary block contains digests of DKGDatas, including a field called active_data which points to the DKGData currently in use. This function first checks if the given summary block has an active_data field that matches the given height, and if so returns <code>active_data</code>, otherwise returns <code>None</code>.</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn get_active_data_at_given_summary(summary_block: &amp;Block, height: Height) -&gt; Option&lt;DkgData&gt; {
    let dkg_summary = &amp;summary_block.payload.as_ref().as_summary().dkg;
    if dkg_summary.current_interval_includes(height) {
        Some(DkgData {
            registry_version: dkg_summary.registry_version,
            high_threshold_transcript: dkg_summary
                .current_transcript(&amp;NiDkgTag::HighThreshold)
                .clone(),
            low_threshold_transcript: dkg_summary
                .current_transcript(&amp;NiDkgTag::LowThreshold)
                .clone(),
        })
    } else if dkg_summary.next_interval_includes(height) {
        let get_transcript_for = |tag| {
            dkg_summary
                .next_transcript(&amp;tag)
                .unwrap_or_else(|| dkg_summary.current_transcript(&amp;tag))
                .clone()
        };
        Some(DkgData {
            registry_version: summary_block.context.registry_version,
            high_threshold_transcript: get_transcript_for(NiDkgTag::HighThreshold),
            low_threshold_transcript: get_transcript_for(NiDkgTag::LowThreshold),
        })
    } else {
        None
    }
}
<span class="boring">}</span></code></pre></pre>
<h3 id="aggregate"><a class="header" href="#aggregate">aggregate</a></h3>
<p>Other replicas on sharing random beacon nominations:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// This function is used to aggregate signature shares into complete artifacts.
///
/// Consensus will receive many artifact signature shares over its lifetime.
/// aggregate attempts to aggregate these signature shares into complete
/// signatures for the corresponding contents.
///
/// For example, aggregate may take a Vec&lt;&amp;RandomBeaconShare&gt; and output a Vec&lt;&amp;RandomBeacon&gt;.
///
/// The behavior of aggregate is as follows:
///
/// Group signature shares by content, producing a mapping from content to
/// vectors of signature shares, where each signature share signed the related content
/// For each (content, shares) pair, look up the threshold and determine if enough
/// shares are present to construct a complete signature for the content
/// If a complete signature can be constructed, attempt to construct the complete
/// signature from the shares
/// If a complete signature can be constructed, construct an artifact using the
/// given content and complete signature
/// Return all successfully constructed artifacts
///
/// Params:
/// artifact_shares - The vector of artifact shares, e.g. Vec&lt;&amp;RandomBeaconShare&gt;
#[allow(clippy::type_complexity)]
pub fn aggregate&lt;
    Message: Eq + Ord + Clone + std::fmt::Debug + HasHeight + HasCommittee,
    CryptoMessage,
    Signature: Ord,
    KeySelector: Copy,
    CommitteeSignature,
    Shares: Iterator&lt;Item = Signed&lt;Message, Signature&gt;&gt;,
&gt;(
    log: &amp;ReplicaLogger,
    membership: &amp;Membership,
    crypto: &amp;dyn Aggregate&lt;CryptoMessage, Signature, KeySelector, CommitteeSignature&gt;,
    selector: Box&lt;dyn Fn(&amp;Message) -&gt; Option&lt;KeySelector&gt; + '_&gt;,
    artifact_shares: Shares,
) -&gt; Vec&lt;Signed&lt;Message, CommitteeSignature&gt;&gt; {
    group_shares(artifact_shares)
        .into_iter()
        .filter_map(|(content_ref, shares)| {
            let selector = selector(&amp;content_ref).or_else(|| {
                warn!(
                    log,
                    &quot;aggregate: cannot find selector for content {:?}&quot;, content_ref
                );
                None
            })?;
            let threshold = match membership
                .get_committee_threshold(content_ref.height(), Message::committee())
            {
                Ok(threshold) =&gt; threshold,
                Err(err) =&gt; {
                    error!(log, &quot;MembershipError: {:?}&quot;, err);
                    return None;
                }
            };
            if shares.len() &lt; threshold {
                return None;
            }
            let shares_ref = shares.iter().collect();
            crypto
                .aggregate(shares_ref, selector)
                .ok()
                .map(|signature| {
                    let content = content_ref.clone();
                    Signed { content, signature }
                })
        })
        .collect()
}
<span class="boring">}</span></code></pre></pre>
<p>DKG Algorithm : https://github.com/dfinity/ic/tree/master/rs/crypto/internal/crypto_lib/fs_ni_dkg
The main code responsible for orchestrating the DKG (sending, receiving and verifying DKG messages and ensuring they make it into the blockchain):
https://github.com/dfinity/ic/blob/master/rs/consensus/src/dkg.rs</p>
<p>Random Beacon:
https://github.com/dfinity/ic/blob/master/rs/consensus/src/consensus/random_beacon_maker.rs</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="message-routing-layer"><a class="header" href="#message-routing-layer">Message routing layer</a></h1>
<h2 id="message-relay-station-in-the-replica"><a class="header" href="#message-relay-station-in-the-replica">Message relay station in the replica</a></h2>
<p>The message routing layer, as its name suggests, is responsible for message transimission within a replica. It acts as an intermediary, interfacing between upper and lower layers.</p>
<h3 id="introduction"><a class="header" href="#introduction">Introduction</a></h3>
<p>The consensus layer packages messages into block payloads. Once a block is finalized, each replica in the subnet parses the payloads in the block. The message routing layer then passes the messages to the corresponding canisters in the execution layer. After executing the messages, the canisters update their internal state and return message responses to the message routing layer.</p>
<img src="2.CoreProtocol/assets/Messageroutinglayer/8167f771-b702-447f-ae30-1207e0835cba.png" alt="image" style="zoom:75%;" />
<p>The messages received by the message routing layer are of two types:</p>
<p>One type is messages from users, called <strong>ingress messages</strong>. The other type is messages from canisters in other subnets, called <strong>cross-subnet messages</strong>.</p>
<p>The messages <strong>sent</strong> by the message routing layer are also of two types:</p>
<p>One is responses to user messages, called <strong>ingress message responses</strong>. The other type is still <strong>cross-subnet messages</strong>, which are messages sent by canisters in its own subnet to canisters in other subnets.</p>
<p><img src="https://github.com/NeutronStarDAO/ICCookBook-English/assets/89145158/891ec713-e47f-4b70-970c-7d7e505df08d" alt="image" /></p>
<h3 id="message-queues"><a class="header" href="#message-queues">Message queues</a></h3>
<p>Each canister in the execution layer has an input queue and an output queue. The message routing layer routes the payloads in the blocks to the input queues of the target canisters.</p>
<p><img src="https://github.com/NeutronStarDAO/ICCookBook-English/assets/89145158/3f798bf7-1ba8-49d5-a5a4-f09e48f2d7d0" alt="image" /></p>
<p>Each canister has its own <strong>input queues</strong> and <strong>output queues</strong>.</p>
<ul>
<li><strong>Input queues</strong>:</li>
</ul>
<p>The input queues contain: messages from users, inter-subnet messages from canisters in other subnets, and messages from other canisters in the subnet.</p>
<p>Each round, the canister executes some messages from the input queues and puts the message responses into the canister's <strong>output queue</strong>.</p>
<ul>
<li><strong>Output queues</strong>:</li>
</ul>
<p>The output queues contain: responses to user messages, messages sent to canisters in other subnets, and messages sent to other canisters within the subnet.</p>
<p>When the message routing layer takes messages from the message queues and puts them into the <strong>subnet-to-subnet streams</strong>, the <strong>crossnet transfer protocol</strong> is responsible for actually transferring these messages to other subnets.</p>
<p>In addition to the output queues, there is an <strong>ingress history</strong> data structure. It records in a hash tree called the &quot;<strong>Per-round certified state</strong>&quot;. The ingress history only records the responses after the canister executes the messages so that users can get responses to their messages.</p>
<blockquote>
<p>Note: The ingress history does not retain a complete history of all ingress messages. It only retains the response messages after execution.</p>
</blockquote>
<p>Looking at the message routing and execution layers separately, it looks like this:</p>
<p><img src="https://github.com/NeutronStarDAO/ICCookBook-English/assets/89145158/8b57f5d6-cf5e-4ed6-9fd9-6667d856e0a4" alt="image" /></p>
<h3 id="intra-subnet-cross-canister-call"><a class="header" href="#intra-subnet-cross-canister-call">Intra-subnet cross-canister call</a></h3>
<p>In addition to cross-subnet messages, there are also messages from one canister calling another canister in the same subnet, called <strong>intra-subnet messages</strong>. The message routing layer forwards these messages directly from the output queue to the input queue of the corresponding canister without an extra round of consensus.</p>
<p>Q: So why do messages from canisters to other subnets require consensus, but messages from canisters to the same subnet do not need consensus?</p>
<p>A: Because these state-changing operations are within the subnet. 😂</p>
<p>Think about it, the data states in the replicas are the same, and consensus is also to ensure the consistency of the data in the replicas. After the replicas reach consensus, each honest replica will execute intra-subnet cross-canister calls, and everyone will execute cross-canister calls together. This is still a consistent operation.</p>
<p>Consensus is used when everyone faces different choices to make everyone execute the same operation.</p>
<p><img src="https://github.com/NeutronStarDAO/ICCookBook-English/assets/89145158/3e47a2ac-169e-4c55-a9f7-dc8d2d1cf2e2" alt="image" /></p>
<p>So when a canister in a subnet calls another canister within the same subnet, each replica will make the same cross-canister call. Each replica stores all the data in the subnet. When the replicas execute cross-canister calls, the consistency of data in the subnet is still maintained.</p>
<p><img src="https://github.com/NeutronStarDAO/ICCookBook-English/assets/89145158/e2f15403-bf6c-4c6c-9aca-620e36e48660" alt="image" /></p>
<h3 id="summary"><a class="header" href="#summary">Summary</a></h3>
<p>The state of a subnet's replica  includes the state of canisters and the &quot;system state&quot;. The &quot;system state&quot; includes the input and output queues of canisters, subnet-to-subnet streams, and ingress history data structures.</p>
<p><img src="https://github.com/NeutronStarDAO/ICCookBook-English/assets/89145158/185c0898-ee51-4b8d-a4cd-fe5098f79d74" alt="image" /></p>
<p>In other words, the message routing layer and the execution layer together maintain the state of a replica. And the state of the replica is updated in a completely deterministic manner, so that all replicas in the subnet maintain the same state. The consensus layer does not need to keep exactly the same progress as the message routing layer.</p>
<h3 id="per-round-certified-state"><a class="header" href="#per-round-certified-state">Per-round certified state</a></h3>
<p>In each round, the state of each replica in the subnet will change.</p>
<p>Of course, the parts that change in each round also need to be recorded separately. Because IC's consensus only guarantees that honest replicas process messages in the same order. Consensus only acts as a &quot;gatekeeper&quot; before messages enter the execution layer, but after message processing, the output is still lacking a &quot;guard&quot;: What if message responses are not sent successfully due to network issues? How does the client verify the authenticity of messages after receiving them? If the message response is made by a hacker, there will be some troubles. What if a strange bug in the server system causes the message not to execute...</p>
<p><img src="https://github.com/NeutronStarDAO/ICCookBook-English/assets/89145158/ea94caeb-d8f0-4c24-8ec9-10085f8a75ac" alt="image" /></p>
<p>Replicas need to check the state again after processing messages. The per-round certified state, also known as the system state tree, acts as this guard and is the last link in a complete round. The per-round certified state can record the state changes of replicas in a round and rebroadcast it to everyone for threshold signature verification, which requires confirmation from two-thirds of the replicas.</p>
<p>After executing messages in every one round, each replica hashes its own generated per-round certified state, packages it into a Merkle tree, and signs it with a private key share. Once two-thirds of the signature share are collected, they are aggregated into a complete signature as the certificate of the per-round certified state for that round.</p>
<blockquote>
<p>Q: Does this consensus algorithm reach agreement only on the inputs to computation, or also on the outputs of computation?</p>
<p>A:  For inputs, they are blocks. For outputs, they are ceritifications. So yes, both inputs and outputs must go through consensus, otherwise we risk divergence.</p>
</blockquote>
<p>The per-round certified state includes:</p>
<ul>
<li>Cross-subnet messages added to subnet-to-subnet data streams in this round</li>
<li>Other metadata, including the ingress history data structure</li>
<li>The root hash of the Merkle tree of the previous per-round certified state</li>
</ul>
<p>The first branch stores various metadata about each canister (but not the full replica state of the canister).</p>
<p>The second branch stores the ingress history data structure.</p>
<p>The third branch stores information about subnet-to-subnet data streams, including a &quot;view&quot; of new cross-subnet messages added to each stream.</p>
<p>Other branches store other types of metadata, which are not discussed here. This tree structure can then be hashed into a Merkle tree.</p>
<p><img src="https://github.com/NeutronStarDAO/ICCookBook-English/assets/89145158/71453f34-e375-4f10-a0f3-9cd16c92a648" alt="image" /></p>
<p>Per-round state certification in IC has the following use cases:</p>
<ul>
<li><strong>Output authentication</strong>. Cross-subnet messages and ingress message responses can be authenticated using per-round certified state. Using the Merkle tree structure, a single output (cross-subnet message or ingress message response) can be authenticated by any party by providing the threshold signature on the root and the hashes on the path (and adjacent) from the root to the leaf in the Merkle tree. Therefore, the number of hashes required to authenticate a single output is proportional to the depth of the Merkle tree, which is usually very small even for very large hash trees. Thus, a single threshold signature can be effectively used to verify many individual outputs.</li>
<li><strong>Preventing and detecting non-determinism</strong>. Consensus ensures that each node processes inputs in the same order. Because each replica deterministically processes these inputs, each replica should reach the same state.</li>
</ul>
<p>However, IC adds an extra layer of robustness by design to detect and prevent any (unintended) non-deterministic computation if it actually occurs.</p>
<p>Among them, the per-round certified state is part of this mechanism, because we use $(n-f)/n$ threshold signatures to certify, and $f &lt; n/3$, so only a single state sequence can be certified.</p>
<p>To understand why chaining states is so important, consider the following example. Suppose we have 4 replica nodes $P_1, P_2, P_3, P_4$, where one replica $P_4$ is malicious. $P_1, P_2, P_3$ start with the same initial state.</p>
<ul>
<li>In round 1, due to non-deterministic computation, $P_1$ and $P_2$ both start computing a message $m_1$ to send to subnet A, while $P_3$ computes $m'_1$ to send to subnet A.</li>
<li>In round 2, $P_1$ and $P_3$ both start computing message $m_2$ to send to subnet $B$, while $P_2$ computes message $m'_2$ to send to subnet $B$.</li>
<li>In round 3, $P_2$ and $P_3$ both start computing message $m_3$ to send to subnet $C$, while $P_1$ computes message $m'_3$ to send to subnet $C$.</li>
</ul>
<p>As express below:</p>
<p>$$ P_1\ \ m_1 \rightarrow A\ \ m_2 \rightarrow B\ \ m'_3 \rightarrow C \ P_2\ \ m_1 \rightarrow A\ \ m'_2 \rightarrow B\ \ m_3 \rightarrow C \ P_3\ \ m'_1 \rightarrow A\ \ m_2 \rightarrow B\ \ m_3 \rightarrow C \ $$ </p>
<p>Let's say $P_1,P_2,P_3$ each executes a valid sequence of computations, but due to non-determinism, these sequences are not the same. (Even though there should be no non-determinism, we still assume its existence in this example.)</p>
<p>Now suppose we do not chain these states. Because $P_4$ is malicious and can sign anything, it can create a $3/4$ threshold signature in state round 1 claiming &quot;$m_1\rightarrow A$&quot;, similarly claim &quot;$m2 \rightarrow B$&quot; in state round 2, and claim &quot;$m_3\rightarrow C$​&quot; in state round 3, despite the corresponding sequence$$ m_1 \rightarrow A, m_2 \rightarrow B, m_3 \rightarrow C $$  may not be compatible with any valid sequence. Worse yet, this invalid computation sequence may have led to inconsistent states across other subnets.</p>
<p>By chaining, we ensure that even with some degree of non-determinism, any authenticated sequence of states corresponds to some valid sequence executed by honest nodes.</p>
<p>Suppose there are 4 replicas, namely $P_1$, $P_2$, $P_3$ and $P_4$, where $P_4$ is assumed to be malicious. Initially, the states of $P_1$, $P_2$, and $P_3$ are the same.</p>
<p>Over the next few rounds, each replica starts computing some messages and sending them to different subnets, namely A, B and C.</p>
<ul>
<li>However, in round 1, $P_1$ and $P_2$ start computing message $m_1$ while $P_3$ computes a different message $m'_1$.</li>
<li>In round 2, $P_1$ and $P_3$ start computing message $m_2$ while $P_2$ computes a different message $m'_2$.</li>
<li>Finally, in round 3, $P_2$ and $P_3$ start computing message $m_3$ while $P_1$ computes a different message $m'_3$.</li>
</ul>
<p>Therefore, each replica computes different messages and their state sequences are not the same. In this example, we assume that there is some non-determinism in the computation that leads each replica to compute different messages and state sequences.</p>
<p>Without addressing this issue, replica $P_4$ can sign whatever it wants since it is malicious.</p>
<p>If we did not chain the states, $P_4$ could:</p>
<ul>
<li>Sign a threshold signature claiming “$m_1\rightarrow A$” in round 1,</li>
<li>Sign a threshold signature claiming “$m_2\rightarrow B$” in round 2,</li>
<li>Finally sign a threshold signature claiming “$m_3\rightarrow C$” in round 3.</li>
</ul>
<p>Even though this sequence of signed messages is invalid and incompatible with any valid sequence, the malicious replica can still forge signatures.</p>
<p>By chaining the states, we ensure that any authenticated sequence of states corresponds to some valid sequence executed by honest replicas, even with some degree of non-determinism. This prevents the malicious replica from abusing its signing rights to nake invalid state sequences and prevents inconsistent states across subnets.</p>
<p>The consensus layer ensures that replicas process messages in a same order. However, during execution, machine failures, unknown system bugs, etc. Could interfere, resulting in failure to execute certain messages.</p>
<p>Therefore, to ensure that each replica processes messages correctly, after a canister executes a message, the executed message must be recorded so that replicas can verify each other.</p>
<p><img src="https://github.com/NeutronStarDAO/ICCookBook-English/assets/89145158/0460952c-91c5-4c58-9380-3671b3393c1b" alt="image" /></p>
<p>//From WhitePaper.</p>
<p><strong>Coordination with consensus.</strong> The per-round certified state is also used to coordinate the execution and consensus layers, in two different ways: </p>
<ol>
<li>Consensus throttling. Each replica will keep track of the latest round for which it has a certified state — this is called the certified height. It will also keep track of the latest round for which it has a notarized block — this is called the notarized height. If the notarized height is significantly greater than the certified height, this is a signal that execution is lagging consensus, and that consensus needs to be throttled. This lagging could be due to non-deterministic computation, or it could just be due to a more benign performance mismatch between the layers. Consensus is throttled by means of the delay functions discussed in Section 5.9 — specifically, each replica will increase the “governor” value  as the gap between notarized height and certified height grows (this makes use of the notion of “locally adjusted delay functions, as in Section 5.12.2). </li>
<li>State-specific payload validation. As discussed in Section 5.7, the inputs in a payload must pass certain validity checks. In fact, these validity checks may depend to a certain degree on the state. A detail we skipped is that each block includes a round number, with the understanding that these validity checks should be made with respect to the certified state for that round number. A replica that needs to perform this validation will wait until the state for that round number has been certified, and then use the certified state for that round to perform the validation. This ensures that even with non-deterministic computation, all replicas are performing the same validity tests (as otherwise, consensus could get stuck).</li>
</ol>
<h3 id="query-calls--update-calls"><a class="header" href="#query-calls--update-calls">Query calls &amp; Update calls</a></h3>
<p>As we have described it so far, ingress messages must pass through consensus so that they are processed in the same order by all replicas on a subnet. However, an important optimization is available to those ingress messages whose processing does not modify the replicated state of a subnet. These are called <strong>query calls</strong> — as opposed to other ingress messages, which are called <strong>update calls</strong>. </p>
<p>Query calls are allowed to perform computations which read and possibly update the state of a canister, but any updates to the state of a canister are never committed to the replicated state. As such, a query call may be processed directly by a single replica without passing through consensus, which greatly reduces the latency for obtaining a response from a query call. </p>
<p>Note that a response to a query call is not recorded in the ingress history data structure. As such, we cannot directly use the per-round certified state mechanism to authenticate responses to query calls. </p>
<p>However, a separate mechanism for authenticating such responses is provided: <strong>certified variables</strong>. As a part of the per-round certified state, each canister on a subnet is allocated a small number of bytes, which is the certified variable for that canister, whose value may be updated via update calls, and may be authenticated using the per-round certified state mechanism. Moreover, a canister may use its certified variable to store a root of a Merkle tree. In this way, a response to a query call to a canister may be authenticated so long the response is a leaf in the Merkle tree rooted at the certified variable for that canister.</p>
<p>.....//Unfinished here</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="execution-layer"><a class="header" href="#execution-layer">Execution Layer</a></h1>
<div style="break-before: page; page-break-before: always;"></div><p>Contributors：</p>
<p><a href="https://github.com/NeutronStarPRO">NeutronStarPRO</a>、</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="references"><a class="header" href="#references">References：</a></h2>
<p>https://eprint.iacr.org/2016/199.pdf</p>
<p>https://internetcomputer.org/whitepaper.pdf</p>
<p>https://internetcomputer.org/how-it-works#Core-IC-Protocol</p>
<p>https://wiki.internetcomputer.org/wiki/Internet_Computer_wiki</p>
<p>https://internetcomputer.org/docs/current/developer-docs/ic-overview</p>
<p>https://medium.com/dfinity/disentangling-dfinity-and-ethereum-dfa2151ad419</p>
<p>https://medium.com/@dominic-w/helo-world-im-back-blogging-ae6ceacbc1d7</p>
<p>https://medium.com/dfinity/the-dfinity-blockchain-nervous-system-a5dd1783288e</p>
<p>https://medium.com/dfinity/dfinity-in-a-nutshell-a-non-technical-introduction-ec45ec5967c1</p>
<p>https://medium.com/dfinity/the-decentralized-cloud-vision-of-the-dfinity-blockchain-f68449c49be2</p>
<p>https://medium.com/dfinity/chain-key-technology-one-public-key-for-the-internet-computer-6a3644901e28</p>
<h2 id="thanks"><a class="header" href="#thanks">Thanks：</a></h2>
<p>Thanks to the official Dfinty, ICPL, DoraHacks, and TinTinLand communities, some of the early video materials are from the WorkShop held by these communities.</p>

                        <div id="giscus-container"></div>
                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script type="text/javascript">
            window.playground_copyable = true;
        </script>

        <script src="ace.js" type="text/javascript" charset="utf-8"></script>
        <script src="editor.js" type="text/javascript" charset="utf-8"></script>
        <script src="mode-rust.js" type="text/javascript" charset="utf-8"></script>
        <script src="theme-dawn.js" type="text/javascript" charset="utf-8"></script>
        <script src="theme-tomorrow_night.js" type="text/javascript" charset="utf-8"></script>

        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>
        <script type="text/javascript" charset="utf-8">
        var pagePath = "print.md"
        </script>


        <!-- Custom JS scripts -->
        <script type="text/javascript" src="assets/custom.js"></script>
        <script type="text/javascript" src="assets/bigPicture.js"></script>

        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>

    </body>
</html>