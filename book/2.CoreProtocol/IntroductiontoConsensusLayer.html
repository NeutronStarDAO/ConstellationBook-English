<!DOCTYPE HTML>
<html lang="zh-CN" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Consensus Layer - ICCookbook</title>


        <!-- Custom HTML head -->
        
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="The IC cookbook for you.">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="../favicon.svg">
        <link rel="shortcut icon" href="../favicon.png">
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        <link rel="stylesheet" href="../css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../highlight.css">
        <link rel="stylesheet" href="../tomorrow-night.css">
        <link rel="stylesheet" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="../theme/style.css">


    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');
                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }
                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="../index.html">ICCookbook</a></li><li class="chapter-item expanded affix "><a href="../JourneytoWeb3/JourneyoftheDreamWeaver.html">Journey of the Dream Weaver</a></li><li class="chapter-item expanded affix "><li class="part-title">Overview of IC</li><li class="chapter-item expanded "><a href="../OverviewofIC/OverviewofIC.html"><strong aria-hidden="true">1.</strong> Internet Computer</a></li><li class="chapter-item expanded "><a href="../Glossary.html"><strong aria-hidden="true">2.</strong> Glossary</a></li><li class="spacer"></li><li class="chapter-item expanded affix "><li class="part-title">Core Protocol</li><li class="chapter-item expanded "><a href="../2.CoreProtocol/Peer-to-peerLayer.html"><strong aria-hidden="true">3.</strong> Peer-to-peer layer</a></li><li class="chapter-item expanded "><a href="../2.CoreProtocol/IntroductiontoConsensusLayer.html" class="active"><strong aria-hidden="true">4.</strong> Consensus Layer</a></li><li class="chapter-item expanded "><a href="../2.CoreProtocol/Messageroutinglayer.html"><strong aria-hidden="true">5.</strong> Message routing layer</a></li><li class="chapter-item expanded "><a href="../2.CoreProtocol/ExecutionLayer.html"><strong aria-hidden="true">6.</strong> Execution Layer</a></li><li class="spacer"></li><li class="chapter-item expanded affix "><li class="part-title">Chain key</li><li class="chapter-item expanded affix "><li class="part-title">NNS</li><li class="chapter-item expanded affix "><li class="part-title">Economic Model</li><li class="chapter-item expanded affix "><li class="part-title">canister</li><li class="chapter-item expanded affix "><li class="part-title">Internet Identity</li><li class="chapter-item expanded affix "><li class="part-title">Cryptography in IC</li><li class="chapter-item expanded affix "><li class="part-title">Dapp Development</li><li class="spacer"></li><li class="chapter-item expanded affix "><a href="../Contributors.html">Contributors</a></li><li class="chapter-item expanded affix "><a href="../References.html">References</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">ICCookbook</h1>

                    <div class="right-buttons">
                        <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/NeutronStarDAO/ICCookBook-English" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');

                    // Get viewed page store
                    var viewed_key = 'mdbook-viewed';
                    var viewed_map = {};
                    try {
                        var viewed_storage = localStorage.getItem(viewed_key);
                        if (viewed_storage) {
                            viewed_map = JSON.parse(viewed_storage)
                        }
                    } catch (e) { }

                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                        
                        // Apply viewed style
                        if (viewed_map[link.pathname]) {
                            link.classList.add('md-viewed')
                        }
                    }); 

                    // Mark viewed after 30s
                    setTimeout(function() {
                        viewed_map[location.pathname] = 1;
                        localStorage.setItem(viewed_key, JSON.stringify(viewed_map));
                    }, 30000)
                </script>

                <div id="content" class="content">
                    <!-- Page table of contents -->
                    <div class="sidetoc"><nav class="pagetoc"></nav></div>
                    <main>
                        <h1 id="introduction-to-consensus-layer"><a class="header" href="#introduction-to-consensus-layer">Introduction to Consensus Layer</a></h1>
<h2 id="what-pouw-isnt-it-pow"><a class="header" href="#what-pouw-isnt-it-pow">What? PoUW? Isn't it Pow?</a></h2>
<p>Consensus on IC ? Take a look at this term: PoUW, Proof of Useful Work.</p>
<p>Does it looks familiar to you?</p>
<img src="assets/Introduction to Consensus Layer/image-20230131200036914.png" alt="image-20230131200036914" style="zoom:20%;" />
<p>Proof of Work (PoW) is the consensus algorithm of Bitcoin, which is very inefficient from today's perspective, but still it is relatively secure. </p>
<p>What is Proof of Work ? </p>
<p>Imagine a school organizing an competitive exam, only students who get full marks are eligible to put their names on the &quot;Honor Wall&quot; of the Education Bureau, they will be also rewarded with one full bitcoin! The school is open 24 hours a day, anyone can come and take the exam at any time, and the results will be released automatically after finishing all the questions. After one student gets full marks, the answer sheets of students who are still taking the exam will be immediately invalidated. That is because the answer (full mark paper) has already been born. In addition,other students must copy the full mark paper and then start the next exam.</p>
<p>In the school of PoUW, the candidates are randomly divided into several classes, and the exams are conducted in these classes. This time,not everyone can enter the school but only teachers can join. Each class completes a set of questions together. Since everyone is supposed to be an experienced teacher, they will roll the dice to decide who gets to do the first question, and who gets to do the second ... After finishing the questions, everyone has to discuss and reach a consensus on various opinions, and then hand in the papers eventually. Each person in the class shares the reward equally.</p>
<br>
<p>How efficient it is!ðŸ˜‰ðŸ˜Ž</p>
<p>PoUW adds a 'U' to PoW, it significantly improves performance and reduces useless work for node machines. PoUW does not artificially create difficult hash calculations. It tries to put as much computing power as possible into serving users of the network. Most resources (CPU, memory) are used to execute codes in Canisters.</p>
<h2 id="how-is-consensus-reached"><a class="header" href="#how-is-consensus-reached">How is consensus reached?</a></h2>
<p>No matter what, Bitcoin is one of ancestors of the blockchain. Even though the consensus is inefficient, it is a solution to distributed system issues.</p>
<p>Satoshi Nakamoto's Bitcoin is a feasible solution to the &quot;Byzantine generals problem&quot;.</p>
<p>Simply put, this problem involves attempts to reach consensus on a course of action through information exchange in an unreliable network with potential threats. Satoshi Nakamoto's solution used the concept of Proof of Work to reach consensus without a centralized authority that needs to be trusted, representing a scientific breakthrough in distributed computing and transcending the widespread applicability of currency.</p>
<br>
<p>However, can consensus only be reached in this way? Is there a more efficient way with high security?</p>
<p>Let's talk about the essence of consensus.</p>
<br>
<p>The essence of consensus is to maintain data consistency in a globally distributed network.</p>
<p>Bitcoin's approach is that everyone competes for computing power to determine who gets to pack valid blocks, then everyone has to copy the winner's blocks. In this way, Bitcoin transaction ledgers will have multiple copies, and the goal of keeping data consistent across all nodes is achieved. However, the efficiency is very low.</p>
<br>
<p>Let's take a look at the logic of consistency here:</p>
<p>The goal: Maintain data consistency across all nodes.</p>
<p>The method: Rely on some means to select a node to pack the block, and others copy the block packed by that node. The same node cannot be selected repeatedly in a continuous way, and the process of getting selected to pack the blocks is random.</p>
<p>Let us analyse the purpose only. Since the purpose is to maintain data consistency between nodes, as long as the nodes receive messages at the same time, the problem will be solved.</p>
<img src="assets/IntroductiontoConsensusLayer/image-20230531145221186.png" alt="image-20230531145221186" style="zoom:25%;" />
<p>In the actual network environment ,it could not be achieved. Information transmission always has varying delays, not to mention that nodes are not located in a same place. The locations of clients are also far and near,the transmission distances are different. It is chaotic and sounds impossible to guarantee that all nodes receive messages at the same time. What should we do?</p>
<p><img src="https://github.com/NeutronStarDAO/ICCookBook-English/assets/89145158/f162c208-3fbe-41c0-85fc-fd8381775760" alt="image" /></p>
<p>The answer is simple. Building a &quot;relay station&quot; can solve this problem. No matter where the messages come from, they are first queued in the relay station, then the relay station sends the messages and execution order to the nodes. As long as the nodes execute the operations in the order received from the relay station, data consistency can be guaranteed!</p>
<p>It is not over yet! Since there is another big issue: Centralization. All nodes have to obey the commands of the relay station. If the relay station says to execute messages in the order of ABDC, the nodes have to follow ABDC. Going round and round a big circle, the result returns to its starting point. So how can we sort messages in a decentralized way?</p>
<br>
<p>Decentralizing is actually simple, that is, doing something completely independent of any other one. There is no &quot;boss&quot; or &quot;manager&quot;.It is very democratic,  everyone works together to reach a consensus. Anyone who comes is allowed to pick up the jobs, and anyone who leaves will not affect the continuous operation of the system. (Unless everyone leaves, but with economic incentives, someone will always come!)</p>
<p>So how can we design it? The nodes need to reach consensus on the order of executing messages and we need to decentralize the working process of the relay station.</p>
<br>
<p>IC is designed like this: (IC abstracts nodes into replicas in subnets)</p>
<p>We could not rely on a relay station. Although the time for messages to arrive at each replica may be different (that is, the time of executing messages is different), all replicas must execute messages in the same order.</p>
<img src="assets/IntroductiontoConsensusLayer/6748452b-c774-40f5-bd91-d28a6ed85520.png" alt="image" style="zoom:25%;" />
<p>Then if everyone's order is different, which order should be executed? It will use random number to decide! (IC's Random Beacon)</p>
<p>IC uses a verifiable random function (VRF) at the base layer. It can generate unpredictable random numbers, and everyone can verify that the random numbers are not made by human.</p>
<p>VRF uses threshold BLS signature scheme. The threshold BLS signature algorithm uses DKG to distribute private key shares to replicas. This is a non-interactive distributed key generation protocol. DKG can distribute private key shares between members. There is no need for a trusted third-party, it does not depend on any member to distribute private key shares, avoiding single points of failure. Everyone uses the private key shares to sign information. Once the signature reaches the threshold, it can be aggregated into a complete signature. The signature process is non-interactive. Any third party can aggregate after receiving enough shares. Anyone can verify the signature with the unique public key. The public key is also recorded in the NNS registry.</p>
<br>
<p>If a message is confirmed, no matter which private key shares participate in the signature, as long as the threshold quantity is reached (the threshold for generating the Random Beacon is one-third), the final unique signature information can be aggregated. For example, the threshold in the following figure is 6. In order for the 16 replicas to generate the random beacon signature for this round, as long as the signature is greater than 6, it can be aggregated.</p>
<img src="./assets/IMG4.png" alt="image" style="zoom:25%;" />
<p>As long as the bad guys get less than one-third of the private key shares, they cannot interfere with the threshold BLS signature. It is also impossible to predict the signature result because the private key shares are not enough. That is to say, no one knows the signature result.</p>
<blockquote>
<p>The consensus of the subnet can resist up to less than one-third malicious replicas. If the malicious replicas are less than one-third, all they can do is sign or not sign, they are unable to interfere with the final result of the threshold signature, nor prevent the signature from being generated. If malicious replicas are greater than or equal to one-third, the subnet has been destroyed, so the random number does not matter. Therefore, the threshold for the random beacon is low, at one-third. The speed of generating random numbers can be faster.</p>
</blockquote>
<ul>
<li>In the traditional RSA algorithm, you control the private key and the message is public, which is equivalent to knowing the signature result yourself. After the private key is leaked, others can also know the signature result in advance.</li>
<li>However, in the threshold BLS  signature algorithm, a group of people control the private key shares. The signer himself does not have the complete private key, so he does not know the signature result. Only after everyone has signed and aggregated ,then they know the signature. Throughout the process, no one knows the global private key, but the signature result is the result recognized by most people. A group of people generate signatures, and no individual can predict the signature result. A single person cannot prevent the signature from being released.</li>
</ul>
<br>
<p>This can serve as Random Beacon to provide a reference for which replica to produce a block. This random number is also a consensus result and cannot be tampered with by a single person. Moreover, this can continuously safely generate random numbers, as long as different information is used for each round of signatures. This different information is naturally the random beacon and some block dkg_ids of the previous round, so that the information signed in each round is different.</p>
<p>IC's random beacon, notarization, finality, random tape, and certified copy status all use threshold BLS signatures. (The random tape and certified copy status are content at the execution layer)</p>
<br>
<h2 id="solution"><a class="header" href="#solution">Solution</a></h2>
<p>Let us take a closer look on how IC's consensus protocol produces a block</p>
<h3 id="preparation-before-block"><a class="header" href="#preparation-before-block">Preparation before block</a></h3>
<p>The consensus protocol produce block by rounds. For example, consensus is reached on the genesis block in round 1, and round 6 for block 6.</p>
<img src="assets/IntroductiontoConsensusLayer/f31ef6bf-b877-4548-9fdc-143f2f8e4685.png" alt="image" style="zoom:70%;" />
<p>Before start, the subnet first randomly selects some replicas to form a &quot;consensus committee&quot; according to the number of replicas. If the number of replicas is too low, all replicas will join the committee. The members in the committee are responsible for producing the blocks, so even if there are a large number of replicas in the subnet, it will not affect performance.</p>
<img src="assets/IntroductiontoConsensusLayer/6af04a3f-b9b1-44b5-b0ff-87fcfddbe9ee.png" alt="image" style="zoom:67%;" />
<p>There is also the concept of &quot;epoch&quot; in the subnet. An epoch is approximately a few hundred rounds. The NNS can adjust the epochs for each subnet.</p>
<p>Each subnet operates within epochs that contain multiple rounds (typically around a few hundred rounds). Different replicas make up the committees in each epoch.</p>
<p><img src="assets/IntroductiontoConsensusLayer/47e1f2e9-5717-4b5d-b1a2-1b788b10803b.png" alt="image" /></p>
<p>At the end of each epoch, the consensus committee members for the next epoch are selected through the random beacon, and the current consensus committee members will all become random beacon committee members in the next epoch.</p>
<br>
<p>The first block of the new epoch contains the list of consensus committee members and random beacon committee members for this epoch.</p>
<p>And at the beginning of the new epoch, the private key shares will be redistributed to the members. This process is called Pro-active resharing of secrets. There are two reasons for doing this:</p>
<ul>
<li>When the members of the subnet change, resharing can ensure that any new member will have new private key shares, and any member exiting the subnet will not have a new private key share.</li>
<li>Even if a small amount of private key shares are leaked to attackers in each epoch, it will not threaten the consensus.</li>
</ul>
<br>
<p>The number of consensus committees is related to the total number of replica members in the subnet. To improve scalability, in small-scale networks, committee members can be all replicas. In large-scale networks, committee members are part of all replicas and constantly changing in each epoch.</p>
<br>
<p>The number of consensus committee members cannot be too large or too small. Too few are insecure, too many affect the consensus speed.</p>
<p>So the relationship between the number of committees and the total number of members has a mathematical model to describe: When the total number of members in the subnet tends to infinity, the hypergeometric distribution tends to the binomial distribution, that is, non-replacement random sampling tends to replacement random sampling. Because the total number of replica members is infinite, there is no difference between replacement and non-replacement. If you are interested, you can read the introduction <strong>here</strong>.</p>
<br>
<p>Once the preparation is complete, blocks can be produced.</p>
<br>
<h3 id="block-maker"><a class="header" href="#block-maker">Block Maker</a></h3>
<p>At the start of each round, the random beacon generated from the previous round produces a ranking to determine the weight of members to produce blocks. The leader with the highest weight is given priority to produce blocks. (As shown in the figure below, the ranking assigns a number from 0 to 4 to the 5 consensus committee members, with 0 having the highest weight)</p>
<p>Under normal circumstances, the leader is honest and the network connection is normal. The leader is responsible for producing blocks. Others are waiting to notarize the leader's block. Even if block from the 2nd maker is received, it will not be notarized until the leader's block is received.</p>
<p>At the same time, the random beacon committee will also package, sign and broadcast the hash of the previous round's beacon and the NiDKG record of this round. When the signature reaches the threshold, this round's random beacon is generated, which also determines the block production weight for the next round.</p>
<img src="assets/IntroductiontoConsensusLayer/6686cda7-0c23-4ae3-aa95-f2f7dffd836b.png" alt="image" style="zoom:70%;" />
<p>A non-genesis block generally contains:</p>
<ul>
<li>The messages received from the time the previous block was notarized to the time this block was packaged, called the &quot;payload&quot;.</li>
<li>The hash of the previous block.</li>
<li>The ranking of the block-producing replica.</li>
<li>The height of the block.</li>
</ul>
<br>
<p>After the block is assembled, the replica responsible for producing the block will generate a <strong>block proposal</strong>, including:</p>
<ul>
<li>The block itself.</li>
<li>Its own identity.</li>
<li>Its own signature on this block.</li>
</ul>
<img src="assets/IntroductiontoConsensusLayer/e8ad34e1-b042-46b8-af32-4da9f28d88ac.png" alt="image" style="zoom:67%;" />
<p>Then broadcast the block proposal to other members.</p>
<p>The leader produces a block and broadcasts it to everyone. After notarization is completed, since only the leader's block is notarized, there is no need for finalization, and it enters the next round. This is the fastest and most common situation. About 1 second to finalize a block. (Optimistic responsiveness: The protocol will continue to execute based on actual network latency rather than the upper limit of network latency)</p>
<br>
<p>If after waiting for a period of time, the leader's block has not been received, it may be that the leader has a poor network or the machine has malfunctioned. Only then will members accept block from 2nd member or 3rd member and notarize their blocks.</p>
<p><img src="assets/IntroductiontoConsensusLayer/bb3cce3c-7016-4f4e-94b2-1b41c2c0ea21.png" alt="image" /></p>
<p>The system has an agreed upon waiting time. If the leader's block is not received within a period of time, it will expect block 2 in the second time period. Then in the third time period, block 3 is expected. If block 3 is its own, then produce the block itself ...</p>
<br>
<h3 id="notarization"><a class="header" href="#notarization">Notarization</a></h3>
<p><strong>Notarization only verifies the reasonableness of the block</strong>, and the notarized block does not represent consensus. This ensures that at least one block in the current round can be notarized.</p>
<p>Therefore, notarization does not mean consensus, nor does it require consensus. If multiple blocks have the same weight, these blocks will be signed.</p>
<br>
<p>During notarization, the members of the consensus committee verify the following three aspects:</p>
<ol>
<li>The block should contain the hash of the block already notarized in the previous round.</li>
<li>The payload of the block must meet certain conditions (specific regulations on the payload content, these conditions are independent of the consensus protocol).</li>
<li>The ranking of the replica responsible for producing this block must correspond to the ranking in the random beacon (for example, if the replica ranked second claims to be ranked first, then this block will not be notarized).</li>
</ol>
<br>
<p>If the block information is correct, the replica responsible for verification first signs the block height and block hash, and then forms a &quot;<strong>notarization share</strong>&quot; with the just signed signature, hash, height, and its own identity. Broadcast the notarized shares.</p>
<img src="./assets/IMG11.png" alt="image" style="zoom:20%;" />
<p>Notarization also uses BLS threshold signatures. When a replica receives enough (the threshold is two-thirds) notarization share, it aggregates the signature share to form a notarization for this block.</p>
<img src="./assets/IMG12.png" alt="image" style="zoom:17%;" />
<p>The aggregated notarization information includes the block hash, block height, aggregated signature, and more than two-thirds of the identity identifiers. Replicas either find that they have collected enough notarization shares and aggregate them into notarizations themselves; or they receive aggregated notarizations from others.</p>
<img src="assets/IntroductiontoConsensusLayer/ebb8aa45-a9a7-412f-8c18-68b0c80f5ccf.png" alt="image" style="zoom:75%;" />
<p>After notarization, the block is still broadcast. When other members receive the already notarized block, they re-broadcast the notarized block and do not generate notarization shares for other blocks.</p>
<br>
<p>For example, in the figure below, the girl holding the cell phone and the blue hat enter the next round of consensus. When the girl sends messages to the other three people, the network is interrupted for 700 milliseconds. The message forwarded by the little blue hat plays a key role. Otherwise, five missing three would not be able to work.</p>
<img src="assets/IntroductiontoConsensusLayer/0a476c14-a9ca-4a25-83e8-bea3d7eff1c8.png" alt="image" style="zoom:25%;" />
<p>If the leader's block has a problem and the notarization fails, the weighting of the second block will now be the largest. If the blocks of the second and the third have both passed notarization, the leader of the next round will choose to block after the block with the greatest weight. As in rounds 5 and 6 below, the weight of the second block is greater than the weight of the third block. Adding up the weights of all blocks, the chain composed of yellow and purple blocks is the chain with the greatest weight.</p>
<img src="assets/IntroductiontoConsensusLayer/6a44e5fe-493d-4cb2-85c7-afd1a0c472f0.png" alt="image" style="zoom:70%;" />
<br>
<h3 id="finalization"><a class="header" href="#finalization">Finalization</a></h3>
<p>Because sometimes more than one block may be generated (when the leader does not respond, the second and the third may produce block to save time). This requires a finalization. The finalization stage will determine the only block that everyone has notarized. Then the blocks before the block that everyone agrees with will also be implicitly finalized, and other branches will become invalid.</p>
<img src="assets/IntroductiontoConsensusLayer/a47ea62b-5d12-4b59-afd1-df442fab6669.png" alt="image" style="zoom:23%;" />
<p>The finalization process is specifically:</p>
<p>After a replica finds a notarized block, it will start checking whether it has notarized any other blocks in this round. If it has not notarized any other blocks, it will broadcast a &quot;finalization share&quot; for the block. To prove that it has only issued a notarization share for this block.</p>
<p>To achieve the finalization of a block, two-thirds of different replicas need to issue finalization share, and then aggregate for the finalization of a block. The format of the finalization share is exactly the same as the notarization share (but marked in a specific way to prevent confusion). After receiving the finalized block, like the notarization process, it will broadcast to other members again.</p>
<p>Note: The replica does not deliberately wait for the aggregation of the finalization share into the finalized before entering the next round. After receiving a finalization share of a certain height, the replica only checks whether it has notarized blocks other than that block, and then broadcasts its own signed finalization share; or forwards the finalization share intact.</p>
<br>
<p>For example, after a replica receives the finalization share of round 10 in round 11, it will check its behaviour at that time and then broadcast a reply.</p>
<p>If after a while, if you receive the finalization of the block in round 10, you can implicitly consider all previous blocks as finalized.</p>
<img src="assets/IntroductiontoConsensusLayer/3142ef13-478b-4683-bbf4-10cea35414fa.png" alt="image" style="zoom:73%;" />
<p>These finalized blocks can be considered as safe confirmed by everyone, meaning that all replicas agree with the branch where the finalized block is located. At the height of block 10, only this block has passed notarization. Then the replica reaches consensus at this height.</p>
<br>
<p>For example:</p>
<p>If a replica only generates a notarization share for one block in Round 5, the replica will also issue a finalization share and then enter Round 6 consensus. If the finalization is received later, the branch containing the finalization is considered valid. If the finalization does not fork afterwards, there will be no problem without finalization.</p>
<p>It is possible that in Round 4, half of the replicas generated notarization shares for the leader and the second blocks, and the other half of the replicas only generated notarization shares for the leader's block. Then the finalization share proposed by the replicas that only notarized the leader's block cannot reach the threshold and cannot obtain finalization. Only half of the replicas generate notarization shares for the second member's block, so the second member's block does not obtain notarization.</p>
<img src="assets/IntroductiontoConsensusLayer/3925837b-88e0-4d66-b75f-51ebe3794b74.png" alt="image" style="zoom:67%;" />
<p>Compared with many other blockchains, the advantage of the IC consensus protocol is that it adopts asynchronous finalization. In other blockchains, nodes usually need to find the longest chain. If the chain forks, the nodes need to wait for a while to find the longest chain. If some blocks are missed due to network failures, the longest chain cannot be found, and data from other nodes needs to be synchronized.</p>
<p>The IC protocol does not rely on finding the &quot;longest chain&quot; to eventually confirm the block. IC's finality method only relies on cryptographic signatures, not on the confirmation of the entire chain. A small number of signatures can observe a block consensus formed without waiting for the confirmation of the entire chain. Forks can be eliminated in a short time, and finalization speeds can be achieved in less than one second.</p>
<br>
<p><strong>The consensus process is over here!</strong></p>
<br>
<p>To summarize, the members of the Consensus Committee need to do 3 things when entering a new round:</p>
<p>(1) See how they rank and then decide whether to produce block yourself</p>
<p>(2) Notarize the block</p>
<p>(3) Observe the blocks, find the main chain, and ignore invalid branches</p>
<p>The Consensus Committee will become a random beacon committee in the next period and be responsible for generating random beacons for each round.</p>
<br>
<p>The consensus process is for the leader to block, everyone verifies and then issues a notarization share, the notarization share reaches the threshold and aggregates into notarization, and enters the next round. Finalization does not have to be completed every round.</p>
<p>The IC consensus protocol ensures that when there are individual malicious attacks, IC's performance will flexibly decrease instead of directly freezing. The consensus protocol currently tends to maximize performance as much as possible in the &quot;optimistic case&quot; without failures.</p>
<p>As the protocol progresses round by round, the blocks connected from the genesis block form a chain that extends continuously. Each block contains a payload, consisting of a series of inputs and the hash of the parent block.</p>
<p>Honest replicas have a consistent view of the path of the blockchain. The blocks record the messages that have been sorted, which are sent by the message routing layer to the execution layer for processing.</p>
<br>
<br>
<h2 id="source-code"><a class="header" href="#source-code">Source Code</a></h2>
<p>https://github.com/dfinity/ic/tree/master/rs/consensus/src/consensus</p>
<h3 id="random_beacon_maker"><a class="header" href="#random_beacon_maker">random_beacon_maker</a></h3>
<p>Threshold BLS signature</p>
<h3 id="on_state_change"><a class="header" href="#on_state_change">on_state_change</a></h3>
<p>If it meets the requirements for proposing random beacon sharing, propose it.</p>
<p>It contains a function called <code>on_state_change</code>. This function accepts a parameter pool of type <code>PoolReader</code> and returns a value of type <code>Option&lt;RandomBeaconShare&gt;</code>. The function of this function is to obtain the current node information and the information in the pool, and determine whether the current node needs to generate a random beacon based on this information. If a random beacon needs to be generated, generate the beacon and return it encapsulated in the <code>RandomBeaconShare</code> structure.</p>
<p>The function first obtains the ID and current height of the current node, and then obtains the random beacon corresponding to the height from the pool. Next, it gets the next height and tries to get the random beacon corresponding to that height from the pool. If the pool does not have this random beacon and the current node belongs to the random beacon committee of that height, generate the random beacon and return it.</p>
<p>The process of generating a random beacon involves creating a <code>RandomBeaconContent</code> structure, which contains the height and hash value. Then, the function will call a function named <code>active_low_threshold_transcript</code> to get the transcript of the current height. If the transcript can be successfully obtained, the <code>crypto.sign</code> method is called to sign the <code>RandomBeaconContent</code> structure. After the signature is successful, the function will return the signature information encapsulated in the <code>RandomBeaconShare</code> structure. If any step has a problem, the function will return <code>None</code>.</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn on_state_change(&amp;self, pool: &amp;PoolReader&lt;'_&gt;) -&gt; Option&lt;RandomBeaconShare&gt; {
    trace!(self.log, &quot;on_state_change&quot;);
    let my_node_id = self.replica_config.node_id;
    let height = pool.get_notarized_height(); // get notarized height of blocks 
    let beacon = pool.get_random_beacon(height)?; // get a random beacon(From pervious round)
    let next_height = height.increment(); // That is the height of the current round (everyone is signing blocks, no decisive blocks have been made, so it's called &quot;next block&quot;).
    let next_beacon = pool.get_random_beacon(next_height); // Get the random beacon for the next block height.
    match self.membership.node_belongs_to_threshold_committee(
        my_node_id,
        next_height,
        RandomBeacon::committee(),
    ) {
        Err(MembershipError::RegistryClientError(_)) =&gt; None,
        Err(MembershipError::NodeNotFound(_)) =&gt; {
            panic!(&quot;This node does not belong to this subnet&quot;)
        }
        Err(MembershipError::UnableToRetrieveDkgSummary(h)) =&gt; {
            error!(
                self.log,
                &quot;Couldn't find transcript at height {} with finalized height {} and CUP height {}&quot;,
                h,
                pool.get_finalized_height(),
                pool.get_catch_up_height()
            );
            None
        }
        Ok(is_beacon_maker)
       // This code uses a match expression that matches a tuple containing two elements.
// The first element is a boolean indicating whether a new random beacon needs to be created for the next height;
// The second element is the next height.
//
// If the first element is true, the first arm is executed, otherwise the second arm is executed.
//
// In the first arm, if the current node is a beacon maker and no random beacon has been generated for the next height
// and the current node has not obtained a share of the random beacon for the next height, then create a random beacon.
// In the second arm, return None.
            if is_beacon_maker
                &amp;&amp; next_beacon.is_none()
                &amp;&amp; !pool
                    .get_random_beacon_shares(next_height)
                    .any(|s| s.signature.signer == my_node_id) =&gt;
        {
            let content =
            // Hash the previous random beacon
            RandomBeaconContent::new(next_height, ic_types::crypto::crypto_hash(&amp;beacon));
// There is an issue of whether it is appropriate to use the dkg_id of the genesis block h
// to generate a random beacon for height h. The reason this is possible is that we actually only generate
// a random beacon for height h after a block at height h exists, and we only use the random
// beacon for height h-1 when verifying the block at height h. Therefore, using the dkg_id
// of the genesis block to generate the random beacon will not affect the validity and correctness of the blocks,
// because in fact the random beacon is only used after the blocks are generated to determine the ranking
// of replica block generation in the next round.
            if let Some(transcript) =
                active_low_threshold_transcript(pool.as_cache(), next_height)
            {
                match self.crypto.sign(&amp;content, my_node_id, transcript.dkg_id) {
                    Ok(signature) =&gt; Some(RandomBeaconShare { content, signature }),
                    Err(err) =&gt; {
                        error!(self.log, &quot;Couldn't create a signature: {:?}&quot;, err);
                        None
                    }
                }
            } else {
                error!(
                    self.log,
                    &quot;Couldn't find the transcript at height {}&quot;, height
                );
                None
            }
        }
        _ =&gt; None,
    }
}
<span class="boring">}</span></code></pre></pre>
<h3 id="get_notarized_height"><a class="header" href="#get_notarized_height">get_notarized_height</a></h3>
<p>It has no parameters. The function returns a <code>Height</code> value.</p>
<p>The purpose of this function is to get the maximum height of the notarized blocks. The following is the implementation of this function:</p>
<p>First, use the <code>get_catch_up_height</code> method to get the highest catch-up package height that has not been processed, and store it in the <code>catch_up_height</code> variable.</p>
<p>Then, extract all verified notarizations from the pool and use the <code>max_height</code> method to get the maximum height of the notarized blocks. If no notarized blocks are found, return <code>catch_up_height</code>.</p>
<p>Finally, select the larger value from <code>catch_up_height</code> and the maximum height of the notarized blocks, and return it as the result.</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn get_notarized_height(&amp;self) -&gt; Height {
    let catch_up_height = self.get_catch_up_height();
    self.pool
        .validated()
        .notarization()
        .max_height()
        .unwrap_or(catch_up_height)
        .max(catch_up_height)
}
<span class="boring">}</span></code></pre></pre>
<h3 id="get_random_beacon"><a class="header" href="#get_random_beacon">get_random_beacon</a></h3>
<p>It has two parameters: <code>self</code>, which is a reference to an object instance, and <code>height</code>, which is a <code>Height</code> value. The function returns an <code>Option&lt;RandomBeacon&gt;</code>.</p>
<p>The purpose of this function is to get a valid random beacon at a given height. The following is the implementation of this function:</p>
<p>First, use the <code>cmp</code> method to compare the given height with the height returned by the <code>get_catch_up_height</code> method. <code>get_catch_up_height</code> returns the highest catch-up package height that has not been processed.</p>
<p>If the given height is less than the height returned by <code>get_catch_up_height</code>, it means that the random beacon at that height has not been generated yet, returning <code>None</code>.</p>
<p>If the given height is equal to the height returned by <code>get_catch_up_height</code>, it means that the random beacon at that height has been included in the highest catch-up package, so extract the random beacon from the catch-up package and return it wrapped in <code>Some</code>.</p>
<p>If the given height is greater than the height returned by <code>get_catch_up_height</code>, it means that the random beacon at that height has been verified in the pool. Therefore, extract the verified random beacon from the pool, and then use the <code>get_only_by_height</code> method to obtain the random beacon by the given height. If it can be obtained, return it, otherwise return <code>None</code>.</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn get_random_beacon(&amp;self, height: Height) -&gt; Option&lt;RandomBeacon&gt; {
    match height.cmp(&amp;self.get_catch_up_height()) {
        Ordering::Less =&gt; None,
        Ordering::Equal =&gt; Some(
            self.get_highest_catch_up_package()
                .content
                .random_beacon
                .as_ref()
                .clone(),
        ),
        Ordering::Greater =&gt; self
            .pool
            .validated()
            .random_beacon()
            .get_only_by_height(height)
            .ok(),
    }
}
<span class="boring">}</span></code></pre></pre>
<h3 id="active_low_threshold_transcript"><a class="header" href="#active_low_threshold_transcript">active_low_threshold_transcript</a></h3>
<p>It has two parameters: <code>reader</code>, which is a reference to an object implementing the <code>ConsensusPoolCache</code> trait, and <code>height</code>, which is a <code>Height</code> value. The function returns an <code>Option&lt;NiDkgTranscript&gt;</code>.</p>
<p>The purpose of this function is to get the active low threshold NiDkg transcript for a given height. The <code>get_active_data_at</code> function is called and passed <code>reader</code> and <code>height</code> as parameters. The return value is mapped to extract the <code>low_threshold_transcript</code> field of the returned data object.</p>
<p>If the <code>get_active_data_at</code> function returns None, the value of the entire expression is None. Otherwise, the <code>low_threshold_transcript</code> field will be extracted and returned wrapped in Option.</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// If found, return the current low transcript for the given height.
pub fn active_low_threshold_transcript(
    reader: &amp;dyn ConsensusPoolCache,
    height: Height,
) -&gt; Option&lt;NiDkgTranscript&gt; {
    get_active_data_at(reader, height).map(|data| data.low_threshold_transcript)
}
<span class="boring">}</span></code></pre></pre>
<h3 id="get_active_data_at"><a class="header" href="#get_active_data_at">get_active_data_at</a></h3>
<p>If active DKGData is found at the given height, return that DKGData.</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn get_active_data_at(reader: &amp;dyn ConsensusPoolCache, height: Height) -&gt; Option&lt;DkgData&gt; {
// There is an issue to note when determining the active DKG data. When using the latest finalized DKG summary,
// there is a problem that the next block or CUP cannot be calculated when the batch lags consensus. This is because only when
// the final block reaches a certain height and points to at least the notarization state of that height can we create the CUP. To solve this problem, the comment
// proposes a solution: first try to use the CUP summary block to determine the active DKG data, and if it fails, try to use the
// newest finalized DKG summary block. This avoids the situation where the next block or CUP cannot be calculated.
    get_active_data_at_given_summary(reader.catch_up_package().content.block.get_value(), height)
        .or_else(|| get_active_data_at_given_summary(&amp;reader.summary_block(), height))
}
<span class="boring">}</span></code></pre></pre>
<h3 id="get_active_data_at_given_summary"><a class="header" href="#get_active_data_at_given_summary">get_active_data_at_given_summary</a></h3>
<p>Returns the active DKGData (DKG data) at the given height according to the given summary block. A summary block is a block at a fixed height that contains some metadata, e.g. public keys for verifying the next consensus proof, digests of DKG data, etc. The height of a summary block is typically a multiple of some regular interval, e.g. one summary block every 100 blocks.</p>
<p>The summary block contains digests of DKGDatas, including a field called active_data which points to the DKGData currently in use. This function first checks if the given summary block has an active_data field that matches the given height, and if so returns <code>active_data</code>, otherwise returns <code>None</code>.</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn get_active_data_at_given_summary(summary_block: &amp;Block, height: Height) -&gt; Option&lt;DkgData&gt; {
    let dkg_summary = &amp;summary_block.payload.as_ref().as_summary().dkg;
    if dkg_summary.current_interval_includes(height) {
        Some(DkgData {
            registry_version: dkg_summary.registry_version,
            high_threshold_transcript: dkg_summary
                .current_transcript(&amp;NiDkgTag::HighThreshold)
                .clone(),
            low_threshold_transcript: dkg_summary
                .current_transcript(&amp;NiDkgTag::LowThreshold)
                .clone(),
        })
    } else if dkg_summary.next_interval_includes(height) {
        let get_transcript_for = |tag| {
            dkg_summary
                .next_transcript(&amp;tag)
                .unwrap_or_else(|| dkg_summary.current_transcript(&amp;tag))
                .clone()
        };
        Some(DkgData {
            registry_version: summary_block.context.registry_version,
            high_threshold_transcript: get_transcript_for(NiDkgTag::HighThreshold),
            low_threshold_transcript: get_transcript_for(NiDkgTag::LowThreshold),
        })
    } else {
        None
    }
}
<span class="boring">}</span></code></pre></pre>
<h3 id="aggregate"><a class="header" href="#aggregate">aggregate</a></h3>
<p>Other replicas on sharing random beacon nominations:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// This function is used to aggregate signature shares into complete artifacts.
///
/// Consensus will receive many artifact signature shares over its lifetime.
/// aggregate attempts to aggregate these signature shares into complete
/// signatures for the corresponding contents.
///
/// For example, aggregate may take a Vec&lt;&amp;RandomBeaconShare&gt; and output a Vec&lt;&amp;RandomBeacon&gt;.
///
/// The behavior of aggregate is as follows:
///
/// Group signature shares by content, producing a mapping from content to
/// vectors of signature shares, where each signature share signed the related content
/// For each (content, shares) pair, look up the threshold and determine if enough
/// shares are present to construct a complete signature for the content
/// If a complete signature can be constructed, attempt to construct the complete
/// signature from the shares
/// If a complete signature can be constructed, construct an artifact using the
/// given content and complete signature
/// Return all successfully constructed artifacts
///
/// Params:
/// artifact_shares - The vector of artifact shares, e.g. Vec&lt;&amp;RandomBeaconShare&gt;
#[allow(clippy::type_complexity)]
pub fn aggregate&lt;
    Message: Eq + Ord + Clone + std::fmt::Debug + HasHeight + HasCommittee,
    CryptoMessage,
    Signature: Ord,
    KeySelector: Copy,
    CommitteeSignature,
    Shares: Iterator&lt;Item = Signed&lt;Message, Signature&gt;&gt;,
&gt;(
    log: &amp;ReplicaLogger,
    membership: &amp;Membership,
    crypto: &amp;dyn Aggregate&lt;CryptoMessage, Signature, KeySelector, CommitteeSignature&gt;,
    selector: Box&lt;dyn Fn(&amp;Message) -&gt; Option&lt;KeySelector&gt; + '_&gt;,
    artifact_shares: Shares,
) -&gt; Vec&lt;Signed&lt;Message, CommitteeSignature&gt;&gt; {
    group_shares(artifact_shares)
        .into_iter()
        .filter_map(|(content_ref, shares)| {
            let selector = selector(&amp;content_ref).or_else(|| {
                warn!(
                    log,
                    &quot;aggregate: cannot find selector for content {:?}&quot;, content_ref
                );
                None
            })?;
            let threshold = match membership
                .get_committee_threshold(content_ref.height(), Message::committee())
            {
                Ok(threshold) =&gt; threshold,
                Err(err) =&gt; {
                    error!(log, &quot;MembershipError: {:?}&quot;, err);
                    return None;
                }
            };
            if shares.len() &lt; threshold {
                return None;
            }
            let shares_ref = shares.iter().collect();
            crypto
                .aggregate(shares_ref, selector)
                .ok()
                .map(|signature| {
                    let content = content_ref.clone();
                    Signed { content, signature }
                })
        })
        .collect()
}
<span class="boring">}</span></code></pre></pre>
<p>DKG Algorithm : https://github.com/dfinity/ic/tree/master/rs/crypto/internal/crypto_lib/fs_ni_dkg
The main code responsible for orchestrating the DKG (sending, receiving and verifying DKG messages and ensuring they make it into the blockchain):
https://github.com/dfinity/ic/blob/master/rs/consensus/src/dkg.rs</p>
<p>Random Beacon:
https://github.com/dfinity/ic/blob/master/rs/consensus/src/consensus/random_beacon_maker.rs</p>

                        <div id="giscus-container"></div>
                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../2.CoreProtocol/Peer-to-peerLayer.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next" href="../2.CoreProtocol/Messageroutinglayer.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../2.CoreProtocol/Peer-to-peerLayer.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next" href="../2.CoreProtocol/Messageroutinglayer.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script type="text/javascript">
            window.playground_copyable = true;
        </script>

        <script src="../ace.js" type="text/javascript" charset="utf-8"></script>
        <script src="../editor.js" type="text/javascript" charset="utf-8"></script>
        <script src="../mode-rust.js" type="text/javascript" charset="utf-8"></script>
        <script src="../theme-dawn.js" type="text/javascript" charset="utf-8"></script>
        <script src="../theme-tomorrow_night.js" type="text/javascript" charset="utf-8"></script>

        <script src="../elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../searcher.js" type="text/javascript" charset="utf-8"></script>

        <script src="../clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="../book.js" type="text/javascript" charset="utf-8"></script>
        <script type="text/javascript" charset="utf-8">
        var pagePath = "2.CoreProtocol/IntroductiontoConsensusLayer.md"
        </script>


        <!-- Custom JS scripts -->
        <script type="text/javascript" src="../assets/custom.js"></script>
        <script type="text/javascript" src="../assets/bigPicture.js"></script>


    </body>
</html>