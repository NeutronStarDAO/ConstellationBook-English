<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Message Routing Layer - Constellation Book</title>


        <!-- Custom HTML head -->
        
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="The constellation book for you.">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="../favicon.svg">
        <link rel="shortcut icon" href="../favicon.png">
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        <link rel="stylesheet" href="../css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../highlight.css">
        <link rel="stylesheet" href="../tomorrow-night.css">
        <link rel="stylesheet" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="../theme/style.css">

        <!-- MathJax -->
        <script async type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

        <script type="text/javascript" async
    src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.9/MathJax.js?config=TeX-MML-AM_CHTML">
        </script>

    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');
                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }
                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item "><a href="../index.html"><strong aria-hidden="true">1.</strong> Constellation Book</a></li><li class="chapter-item affix "><li class="part-title">Journey of the Dream Weaver</li><li class="chapter-item "><a href="../0.JourneytoWeb3/JourneyoftheDreamWeaver.html"><strong aria-hidden="true">2.</strong> Journey of the Dream Weaver</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../0.JourneytoWeb3/NavigatingtheFrontiersofTomorrow.html"><strong aria-hidden="true">2.1.</strong> Future Has Come</a></li><li class="chapter-item "><a href="../0.JourneytoWeb3/ThingsaboutCryptoPunks.html"><strong aria-hidden="true">2.2.</strong> Things About Crypto Punks</a></li><li class="chapter-item "><a href="../0.JourneytoWeb3/WhatistheBlockchain.html"><strong aria-hidden="true">2.3.</strong> What is Blockchain?</a></li><li class="chapter-item "><a href="../0.JourneytoWeb3/WhatisEthereum.html"><strong aria-hidden="true">2.4.</strong> What is Ethereum?</a></li><li class="chapter-item "><a href="../0.JourneytoWeb3/Whathappenedtomyprivacyontheinternet.html"><strong aria-hidden="true">2.5.</strong> What Happened to My Privacy on the Internet?</a></li><li class="chapter-item "><a href="../0.JourneytoWeb3/Bitcoin.html"><strong aria-hidden="true">2.6.</strong> Bitcoin</a></li></ol></li><li class="chapter-item "><li class="part-title">Overview of IC</li><li class="chapter-item "><a href="../1.OverviewofIC/1.html"><strong aria-hidden="true">3.</strong> Internet Computer</a></li><li class="spacer"></li><li class="chapter-item affix "><li class="part-title">Core Protocol</li><li class="chapter-item "><a href="../2.CoreProtocol/P2Player.html"><strong aria-hidden="true">4.</strong> Peer-to-peer Layer</a></li><li class="chapter-item "><a href="../2.CoreProtocol/IntroductiontoConsensusLayer.html"><strong aria-hidden="true">5.</strong> Consensus Layer</a></li><li class="chapter-item expanded "><a href="../2.CoreProtocol/Messageroutinglayer.html" class="active"><strong aria-hidden="true">6.</strong> Message Routing Layer</a></li><li class="chapter-item "><a href="../2.CoreProtocol/executionLayer.html"><strong aria-hidden="true">7.</strong> Execution Layer</a></li><li class="chapter-item "><a href="../2.CoreProtocol/Relatedconcepts/Introduction.html"><strong aria-hidden="true">8.</strong> Related Concepts</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../2.CoreProtocol/Relatedconcepts/HowToPickNumberInConsensus.html"><strong aria-hidden="true">8.1.</strong> How to Pick the Number of Consensus Committee?</a></li><li class="chapter-item "><a href="../2.CoreProtocol/Relatedconcepts/P2PLayerAndMaliciousAttack.html"><strong aria-hidden="true">8.2.</strong> How Does P2P Layer Reduce Malicious Attack?</a></li></ol></li><li class="chapter-item "><li class="part-title">Chain-Key Cryptography</li><li class="chapter-item affix "><li class="part-title">Network Nervous System</li><li class="chapter-item affix "><li class="part-title">Canister</li><li class="chapter-item affix "><li class="part-title">Economic Model</li><li class="chapter-item affix "><li class="part-title">Internet Identity</li><li class="chapter-item affix "><li class="part-title">Cryptography in IC</li><li class="chapter-item affix "><li class="part-title">Dapp Development</li><li class="spacer"></li><li class="chapter-item affix "><a href="../Glossary.html">Glossary</a></li><li class="chapter-item affix "><a href="../Contributors.html">Contributors</a></li><li class="chapter-item affix "><a href="../References.html">References</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Constellation Book</h1>

                    <div class="right-buttons">
                        <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/NeutronStarDAO/ConstellationBook-English" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');

                    // Get viewed page store
                    var viewed_key = 'mdbook-viewed';
                    var viewed_map = {};
                    try {
                        var viewed_storage = localStorage.getItem(viewed_key);
                        if (viewed_storage) {
                            viewed_map = JSON.parse(viewed_storage)
                        }
                    } catch (e) { }

                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                        
                        // Apply viewed style
                        if (viewed_map[link.pathname]) {
                            link.classList.add('md-viewed')
                        }
                    }); 

                    // Mark viewed after 30s
                    setTimeout(function() {
                        viewed_map[location.pathname] = 1;
                        localStorage.setItem(viewed_key, JSON.stringify(viewed_map));
                    }, 30000)
                </script>

                <div id="content" class="content">
                    <!-- Page table of contents -->
                    <div class="sidetoc"><nav class="pagetoc"></nav></div>
                    <main>
                        <h1 id="message-routing-layer"><a class="header" href="#message-routing-layer">Message routing layer</a></h1>
<h2 id="message-relay-station-in-the-replica"><a class="header" href="#message-relay-station-in-the-replica">Message relay station in the replica</a></h2>
<p>The message routing layer, as its name suggests, is responsible for message transimission within a replica. It acts as an intermediary, interfacing between upper and lower layers.</p>
<h3 id="introduction"><a class="header" href="#introduction">Introduction</a></h3>
<p>The consensus layer packages messages into block <strong>payloads</strong>. Once a block is finalized, each replica in the subnet parses the payloads in the block. The message routing layer then passes the messages to the corresponding canisters in the execution layer. After executing the messages, the canisters update their internal state and return message responses to the message routing layer.</p>
<img src="assets/Messageroutinglayer/image-20230709152648678.png" alt="image-20230709152648678" style="zoom: 80%;" />
<p>The messages received by the message routing layer are of two types:</p>
<p>One type is messages from users, called <strong>ingress messages</strong>. The other type is messages from canisters in other subnets, called <strong>cross-subnet messages</strong>.</p>
<p>The messages <strong>sent</strong> by the message routing layer are also of two types:</p>
<p>One is responses to user messages, called <strong>ingress message responses</strong>. The other type is still <strong>cross-subnet messages</strong>, which are messages sent by canisters in its own subnet to canisters in other subnets.</p>
<img src="assets/Messageroutinglayer/image-20230710010119385.png" alt="image-20230710010119385" style="zoom: 67%;" />
<h3 id="message-queues"><a class="header" href="#message-queues">Message queues</a></h3>
<p>Each canister in the execution layer has an input queue and an output queue. The message routing layer routes the payloads in the blocks to the input queues of the target canisters.</p>
<img src="assets/Messageroutinglayer/IMG21.png" alt="IMG21" style="zoom: 67%;" />
<p>Each canister has its own <strong>input queues</strong> and <strong>output queues</strong>.</p>
<ul>
<li><strong>Input queues</strong>:</li>
</ul>
<p>The input queues contain: messages from users, inter-subnet messages from canisters in other subnets, and messages from other canisters in the subnet.</p>
<p>Each round, the canister executes some messages from the input queues and puts the message responses into the canister's <strong>output queue</strong>.</p>
<ul>
<li><strong>Output queues</strong>:</li>
</ul>
<p>The output queues contain: responses to user messages, messages sent to canisters in other subnets, and messages sent to other canisters within the subnet.</p>
<p>When the message routing layer takes messages from the message queues and puts them into the <strong>subnet-to-subnet streams</strong>, the <strong>crossnet transfer protocol</strong> is responsible for actually transferring these messages to other subnets.</p>
<p>In addition to the output queues, there is an <strong>ingress history</strong> data structure. It records in a hash tree called the &quot;<strong>Per-round certified state</strong>&quot;. The ingress history only records the responses after the canister executes the messages so that users can get responses to their messages.</p>
<blockquote>
<p>Note: The ingress history does not retain a complete history of all ingress messages. It only retains the responses after update calls.</p>
<p>The responses of query calls are not recorded in the ingress history (the ingress history only records the responses of update calls), so they cannot be verified by each round of authentication status. But IC provides another verification mechanism, called certified variables. We can store some important information using certified variables.</p>
<p>If the content of a query call is a certified variable, then the query call is secure and verifiable. Because the certified variables of the Canister are also recorded in each round of authentication status after hashing. And each round of authentication status is consensus-based, meaning that this information is the same in all replicas in the subnet.</p>
</blockquote>
<p>Looking at the message routing and execution layers separately, it looks like this:</p>
<p><img src="assets/Messageroutinglayer/image-20230710141512786.png" alt="image-20230710141512786" /></p>
<h2 id="intra-subnet-messages"><a class="header" href="#intra-subnet-messages">Intra-subnet messages</a></h2>
<p>When a Canister sends information to Canisters in other subnets, this information is placed in the cross-subnet queue and verified by the subnet at the end of this round. The receiving subnet can confirm that the information is authorized by the sender by verifying the signature. These messages require consensus. IC implements cross-subnet communication using the Xnet protocol, which will be introduced in detail later.</p>
<h3 id="intra-subnet-cross-canister-call"><a class="header" href="#intra-subnet-cross-canister-call">Intra-subnet cross-canister call</a></h3>
<p>In addition to cross-subnet messages, there are also messages from one canister calling another canister in the same subnet, called <strong>intra-subnet messages</strong>. The message routing layer forwards these messages directly from the output queue to the input queue of the corresponding canister without an extra round of consensus.</p>
<p>So why do messages from canisters to other subnets require consensus, but messages from canisters to the same subnet do not need consensus?</p>
<p>Because these state-changing operations are within the subnet. </p>
<p>Think about it, the data states in the replicas are the same, and consensus is also to ensure the consistency of the data in the replicas. After the replicas reach consensus, each honest replica will execute intra-subnet cross-canister calls, and everyone will execute cross-canister calls together. This is still a consistent operation.</p>
<p>Consensus is used when everyone faces different choices to make everyone execute the same operation.</p>
<p><img src="assets/Messageroutinglayer/image-20230710142242883.png" alt="image-20230710142242883" /></p>
<p>So when a canister in a subnet calls another canister within the same subnet, each replica will make the same cross-canister call. Each replica stores all the data in the subnet. When the replicas execute cross-canister calls, the consistency of data in the subnet is still maintained.</p>
<p><img src="assets/Messageroutinglayer/image-20230710151201556.png" alt="image-20230710151201556" /></p>
<p><strong>Guarantees provided by the message routing layer</strong></p>
<ol>
<li>Cross-subnet messages must be delivered to the execution layer of the target Canister subnet at one time.</li>
<li>If a message cannot be delivered, a rejection response must be generated.</li>
<li>If a Canister A sends two messages m1 and m2 to Canister B, and if they are not rejected, it must be guaranteed that they are placed in Canister B's input queue in order.</li>
</ol>
<h2 id="summary"><a class="header" href="#summary">Summary</a></h2>
<p>At this point, let's summarize. The state of a replica (subnet) includes the state of Canisters and &quot;system state&quot;. The &quot;system state&quot; includes the input and output queues of Canisters, cross-subnet data streams, and the ingress history data structure.</p>
<img src="assets/Messageroutinglayer/IMG25.png" alt="IMG25" style="zoom: 80%;" />
<p>In other words, the message routing layer and the execution layer together maintain the state of a replica. And the state of the replica is updated under fully deterministic conditions, so that all replicas in the subnet maintain exactly the same state. The consensus layer does not need to keep exactly the same progress as the message routing layer.</p>
<h2 id="per-round-certified-state"><a class="header" href="#per-round-certified-state">Per-round certified state</a></h2>
<p>In each round, the state of each replica in the subnet will change.</p>
<p>Of course, the part that changes in each round also needs to be recorded separately. Because IC's consensus only guarantees that honest replicas process messages in the same order. Consensus only guards before messages enter the execution layer, but the exit after message processing lacks a &quot;guard&quot;: What if the message response is not sent successfully due to network issues? How does the client verify the authenticity of the message after receiving the message? If the message response is forged by hackers, it will be troublesome. In case the server system has strange bugs that prevent messages from being executed...</p>
<img src="assets/Messageroutinglayer/IMG26.png" alt="IMG26" style="zoom: 80%;" />
<p>Replicas need to verify the state again after processing messages. The <strong>per-round certified state</strong>, also known as the system state tree, serves as the last guard in a complete round. The per-round certified state can record the state changes of replicas in one round, and re-broadcast a threshold signature to everyone for confirmation by two-thirds of the replicas.</p>
<p>Both input and output must be certified by consensus, otherwise there is a risk of divergence.</p>
<p>Therefore, in order to ensure that each replica processes the message correctly, after the Canister executes the message, the executed message must be recorded to allow the replicas to verify each other again.</p>
<img src="assets/Messageroutinglayer/image-20230710144332663.png" alt="image-20230710144332663" style="zoom:67%;" />
<p>After executing messages in each round, each replica hashes its own per-round certified state, packs it into a Merkle tree, and signs it with a private key fragment. Collect two-thirds of the signature fragments to aggregate into a complete signature. The state tree and the certified signature are called the per-round certified state.</p>
<p>Because the execution layer processes messages in the same way, theoretically each replica in the subnet will independently create the same tree.</p>
<p>The per-round state tree only contains some data information that has changed after each round of execution. The overall state of the replica is not in the per-round certified state.</p>
<img src="assets/Messageroutinglayer/image-20230706141701491.png" alt="image-20230706141701491" style="zoom:50%;" />
<p>Each round of certification states contains the following in this round:</p>
<ul>
<li>Various metadata about each Canister (such as the hash of wasm, etc., not the complete status of the Canister)</li>
<li>The root node hash of the Merkle tree of the certification status of the previous round</li>
<li>Intra-subnet messages added to the data flow between subnets</li>
<li>Ingress history, various responses to messages</li>
<li>The ID and public key of each subnet</li>
<li>Current time</li>
<li>Metadata</li>
</ul>
<p>The consensus layer and execution layer of IC are separated and are two independent parts. The consensus layer and execution layer can also adjust their own rhythms and speeds. If the consensus is too fast and the execution layer accumulates too many messages to keep up with the consensus, message routing needs to notify the consensus layer to slow down. (It may be due to some bugs in the execution layer, etc.) <strong>Here</strong> we see how the consensus slows down.</p>
<p>How do you know if the execution layer is slow? Through the certification status of each round. Each replica will observe the round of threshold signature certification and the round of consensus reaching in each round. If the difference is too large, the speed must be reduced.</p>
<img src="assets/Messageroutinglayer/z.gif" alt="z" style="zoom: 80%;" />
<p>Just like the assembly line in a traditional factory, if one part slows down, the entire production line has to slow down. Otherwise, the backlog of messages to be processed will accumulate more and more.</p>
<h2 id="xnet-protocol"><a class="header" href="#xnet-protocol">XNet Protocol</a></h2>
<p>IC implements communication between subnets through the XNet protocol. In order to reduce the latency of message transmission, replicas tend to choose replicas closer to themselves for communication.</p>
<p>Simply put, cross-subnet messages are transmitted as follows:</p>
<p>After the Canister in the execution layer processes the message, it puts the cross-subnet message into the output queue. The message routing layer has a component called the <strong>Stream builder</strong>, which is responsible for forming cross-subnet messages into data streams. After <strong>Per-round state</strong> threshold signature certification, the XNet endpoint of the replica executes and sends. The <strong>XNet endpoint</strong> sends messages to the nearest replica of subnet B. After the replica XNet payload builder of subnet B receives the message, it broadcasts the payload. Then pack it out and reach consensus.</p>
<img src="assets/Messageroutinglayer/image-20230710010807353.png" alt="image-20230710010807353" style="zoom:43%;" />
<p><strong>The Stream builder</strong> extracts messages from the Canister's output queue and queues the messages. It needs to meet determinism, orderliness and fairness:</p>
<ol>
<li>Determinism: All replicas must reach consensus on the content of the stream. (Replicas perform threshold signature certification for each round of state certification)</li>
<li>Orderliness: If Canister A sends a request R1 to Canister B first, then sends a request R2, then R1 is ahead of R2 in the data stream.</li>
<li>Fairness: We do not want a Canister to occupy too much bandwidth. The Stream builder will try to give each Canister the same bandwidth.</li>
</ol>
<p>The Stream builder sorts these messages according to the target subnet and forms message streams (one message stream per target subnet). Each message in the message stream has a unique increasing index.</p>
<p>After that,  **per-round certified state ** will certify the submitted state. After the certification is completed, the certified data stream can be sent to other subnets.</p>
<p>The <strong>XNet endpoint</strong> is responsible for sending certified messages to other subnets. The XNet endpoint is a component that provides messages to other subnets. It provides services through secure TLS connections and only accepts connections from other replicas. The XNet endpoint obtains a complete list of nodes, subnet allocation, IP addresses and public keys (for establishing TLS connections) from the registry.</p>
<img src="assets/Messageroutinglayer/image-20230709153806949.png" alt="image-20230709153806949" style="zoom:37%;" />
<p>If a replica of subnet B wants to get new messages from subnet A, it will choose the nearest replica of subnet A and send a request to this replica through the XNet protocol. XNet transmits information through the HTTPS protocol.</p>
<p><strong>The XNet payload builder</strong> is responsible for receiving cross-subnet messages. As the name suggests, after receiving these messages, it will package them as payloads into blocks, reach consensus, execute ...</p>
<p>In addition to cross-subnet messages, user ingress messages and Bitcoin transactions (for subnets enabling Bitcoin integration) will also be packaged as payloads into blocks.</p>
<img src="assets/Messageroutinglayer/image-20230710010416109.png" alt="image-20230710010416109" style="zoom: 25%;" />
<p>After combining and packaging these payloads into a block, the consensus protocol will verify the entire block and reach consensus. After the consensus is reached, the messages in the payload will be processed.</p>
<p>This is the process of transmitting messages from one subnet to another subnet. As shown in the figure below.</p>
<img src="assets/Messageroutinglayer/image-20230710135919388.png" alt="image-20230710135919388" style="zoom:67%;" />
<p>Garbage collection: After sending the messages, subnet A still needs to tell subnet B which messages have been processed so that subnet A can clear those messages that are no longer needed.</p>
<p>These components ensure that cross-subnet messages can be delivered correctly and implement secure and scalable blockchain communication.</p>

                        <div id="giscus-container"></div>
                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../2.CoreProtocol/IntroductiontoConsensusLayer.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next" href="../2.CoreProtocol/executionLayer.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../2.CoreProtocol/IntroductiontoConsensusLayer.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next" href="../2.CoreProtocol/executionLayer.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script type="text/javascript">
            window.playground_copyable = true;
        </script>

        <script src="../ace.js" type="text/javascript" charset="utf-8"></script>
        <script src="../editor.js" type="text/javascript" charset="utf-8"></script>
        <script src="../mode-rust.js" type="text/javascript" charset="utf-8"></script>
        <script src="../theme-dawn.js" type="text/javascript" charset="utf-8"></script>
        <script src="../theme-tomorrow_night.js" type="text/javascript" charset="utf-8"></script>

        <script src="../elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../searcher.js" type="text/javascript" charset="utf-8"></script>

        <script src="../clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="../book.js" type="text/javascript" charset="utf-8"></script>
        <script type="text/javascript" charset="utf-8">
        var pagePath = "2.CoreProtocol/Messageroutinglayer.md"
        </script>


        <!-- Custom JS scripts -->
        <script type="text/javascript" src="../assets/custom.js"></script>
        <script type="text/javascript" src="../assets/bigPicture.js"></script>


    </body>
</html>